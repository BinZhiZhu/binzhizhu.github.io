<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[高仿快递智能识别地址功能]]></title>
    <url>%2F2018%2F12%2F14%2F%E9%AB%98%E4%BB%BF%E5%BF%AB%E9%80%92%E6%99%BA%E8%83%BD%E8%AF%86%E5%88%AB%E5%9C%B0%E5%9D%80%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[前言 这周接到一个项目功能，大致就类似快递类寄件智能识别收货地址，只需要复制粘贴地址信息，点击完成就直接填写到了对应的地址信息的输入框。 我简单的举个例子吧： 小埋13000000000广东省广州市天河区体育西路xxx号 上面就会自动识别为： 收货人：小埋 电话：13000000000 省市区：广东省 广州市 天河区 地址：体育西路xxx号这样就认为是智能识别了，不需要一个一个去手动填写，只需要复制粘贴物流地址信息即可。说是这样说，但实际上内心是一万只曹尼玛 ^ ^ 前期准备 我开始是再Google搜索有没有相关的第三方SDK，一般都会这样去思考，只需要调第三方sdk接口即可，但是实际上会有一个问题：地址库！！！ 现公司内部使用的地址库是腾讯开发的Jquery Weui组件库中的cityPicker，也就是填写省市区的地址选择器，所以地址库不统一的话是一个硬伤。 gayHub 地址 [smart-parse]: https://github.com/BinZhiZhu/smart-parse]]></content>
  </entry>
  <entry>
    <title><![CDATA[mysql-Expression #1 of SELECT list is not in GROUP BY clause解决方案]]></title>
    <url>%2F2018%2F11%2F30%2Fmysql-Expression-1-of-SELECT-list-is-not-in-GROUP-BY-clause%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[##前言 最近部署自己项目到服务器后，运行时mysql报错，抛出异常的代码为： 1Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column &apos;support_desk.mod_users_groups.group_id&apos; which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by 谷歌翻译一下大概意思： SELECT列表的表达式＃1不在GROUP BY子句中，并且包含非聚合列’support_desk.mod_users_groups.group_id’，它在功能上不依赖于GROUP BY子句中的列; 这与sql_mode = only_full_group_by不兼容 解决方案 实锤是因为MySQL版本的原因，我去StackOverflow查了相关的解决方案，最终还是解决了这个问题。 cd /etc/my.cnf 或者etc/mysql/my.cnf 不清楚路径可以 whereis my.cnf 打印pwd路径 vim my.cnf 添加sql_mode 12[mysqld] sql_mode = STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION esc :wq 报错退出 重启一下mysql服务 sudo service mysql restart / 或者/etc/init.d/mysql restart等等都可以 除了上面这种方法也可以直接连接mysql 通过mysql-&gt;set …[sql_mode] 类似 这样问题就解决了，最后贴一下解决方案的地址 [stackoverflow]：https://stackoverflow.com/questions/34115174/error-related-to-only-full-group-by-when-executing-a-query-in-mysql]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[探讨Tencent/weui.js之picker组件库]]></title>
    <url>%2F2018%2F11%2F30%2F%E6%8E%A2%E8%AE%A8Tencent-weui-js%E4%B9%8Bpicker%E7%BB%84%E4%BB%B6%E5%BA%93%2F</url>
    <content type="text"><![CDATA[Functionspicker(items, options)picker 多列选择器。datePicker(options)datePicker 时间选择器，由picker拓展而来，提供年、月、日的选择。 picker(items, options)picker 多列选择器。 Kind: global function Param Type Default Description items array picker的数据，即用于生成picker的数据，picker的层级可以自己定义，但建议最多三层。数据格式参考example。 options Object 配置项 [options.depth] number picker深度(也就是picker有多少列) 取值为1-3。如果为空，则取items第一项的深度。 [options.id] string &quot;default&quot; 作为picker的唯一标识，作用是以id缓存当时的选择。（当你想每次传入的defaultValue都是不一样时，可以使用不同的id区分） [options.className] string 自定义类名 [options.container] string 指定容器 [options.defaultValue] array 默认选项的value数组 [options.onChange] function 在picker选中的值发生变化的时候回调 [options.onConfirm] function 在点击”确定”之后的回调。回调返回选中的结果(Array)，数组长度依赖于picker的层级。 [options.onClose] function picker关闭后的回调 Example12345678910111213141516171819202122232425262728293031// 单列pickerweui.picker([&#123; label: '飞机票', value: 0, disabled: true // 不可用&#125;,&#123; label: '火车票', value: 1&#125;,&#123; label: '汽车票', value: 3&#125;,&#123; label: '公车票', value: 4,&#125;], &#123; className: 'custom-classname', container: 'body', defaultValue: [3], onChange: function (result) &#123; console.log(result) &#125;, onConfirm: function (result) &#123; console.log(result) &#125;, id: 'singleLinePicker'&#125;); Example123456789101112131415161718192021222324252627282930313233// 多列pickerweui.picker([ &#123; label: '1', value: '1' &#125;, &#123; label: '2', value: '2' &#125;, &#123; label: '3', value: '3' &#125;], [ &#123; label: 'A', value: 'A' &#125;, &#123; label: 'B', value: 'B' &#125;, &#123; label: 'C', value: 'C' &#125;], &#123; defaultValue: ['3', 'A'], onChange: function (result) &#123; console.log(result); &#125;, onConfirm: function (result) &#123; console.log(result); &#125;, id: 'multiPickerBtn'&#125;); Example12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// 级联pickerweui.picker([&#123; label: '飞机票', value: 0, children: [ &#123; label: '经济舱', value: 1 &#125;, &#123; label: '商务舱', value: 2 &#125; ]&#125;,&#123; label: '火车票', value: 1, children: [ &#123; label: '卧铺', value: 1, disabled: true // 不可用 &#125;, &#123; label: '坐票', value: 2 &#125;, &#123; label: '站票', value: 3 &#125; ]&#125;,&#123; label: '汽车票', value: 3, children: [ &#123; label: '快班', value: 1 &#125;, &#123; label: '普通', value: 2 &#125; ]&#125;], &#123; className: 'custom-classname', container: 'body', defaultValue: [1, 3], onChange: function (result) &#123; console.log(result) &#125;, onConfirm: function (result) &#123; console.log(result) &#125;, id: 'doubleLinePicker'&#125;); datePicker(options)datePicker 时间选择器，由picker拓展而来，提供年、月、日的选择。 Kind: global function Param Type Default Description options 配置项 [options.id] string &quot;datePicker&quot; 作为picker的唯一标识 [options.start] number &#124; string &#124; Date 2000 起始年份，如果是 Number 类型，表示起始年份；如果是 String 类型，格式为 ‘YYYY-MM-DD’；如果是 Date 类型，就传一个 Date [options.end] number &#124; string &#124; Date 2030 结束年份，同上 [options.cron] string &quot; *&quot; cron 表达式，三位，分别是 dayOfMonth[1-31]，month[1-12] 和 dayOfWeek[0-6]（周日-周六） [options.className] string 自定义类名 [options.defaultValue] array 默认选项的value数组, 如 [1991, 6, 9] [options.onChange] function 在picker选中的值发生变化的时候回调 [options.onConfirm] function 在点击”确定”之后的回调。回调返回选中的结果(Array)，数组长度依赖于picker的层级。 Example12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// 示例1：weui.datePicker(&#123; start: 1990, end: 2000, defaultValue: [1991, 6, 9], onChange: function(result)&#123; console.log(result); &#125;, onConfirm: function(result)&#123; console.log(result); &#125;, id: 'datePicker'&#125;);// 示例2：weui.datePicker(&#123; start: new Date(), // 从今天开始 end: 2030, defaultValue: [2020, 6, 9], onChange: function(result)&#123; console.log(result); &#125;, onConfirm: function(result)&#123; console.log(result); &#125;, id: 'datePicker' &#125;); // 示例3：weui.datePicker(&#123; start: new Date(), // 从今天开始 end: 2030, cron: '* * 0,6', // 每逢周日、周六 onChange: function(result)&#123; console.log(result); &#125;, onConfirm: function(result)&#123; console.log(result); &#125;, id: 'datePicker' &#125;); // 示例4：weui.datePicker(&#123; start: new Date(), // 从今天开始 end: 2030, cron: '1-10 * *', // 每月1日-10日 onChange: function(result)&#123; console.log(result); &#125;, onConfirm: function(result)&#123; console.log(result); &#125;, id: 'datePicker' &#125;);]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>weui</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[探讨Tencent/weui.js]]></title>
    <url>%2F2018%2F11%2F30%2F%E6%8E%A2%E8%AE%A8Tencent-weui-js%2F</url>
    <content type="text"><![CDATA[##认识WeUI WeUI 的轻量级 js 封装。 注意：由于微信小程序不支持dom操作，所以weui.js并不适用于小程序。不过WeUI也为小程序开发了另外的版本，详情请看：https://github.com/Tencent/weui-wxss/ 手机预览：https://weui.io/weui.js/ ##安装 1234git clone https://github.com/Tencent/weui.js.gitcd weui.jsnpm installnpm start ##编译 1npm run build ##使用 global123456&lt;link rel=&quot;stylesheet&quot; href=&quot;https://res.wx.qq.com/open/libs/weui/1.1.3/weui.min.css&quot;&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;https://res.wx.qq.com/open/libs/weuijs/1.1.4/weui.min.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; weui.alert(&apos;alert&apos;);&lt;/script&gt; import as module1234import &apos;weui&apos;;import weui from &apos;weui.js&apos;;weui.alert(&apos;alert&apos;); ##文档 [文档]：https://github.com/Tencent/weui.js/blob/master/docs/README.md ##Github [github]：https://github.com/Tencent/weui.js]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>weui</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[fsockopen实现发起异步请求忽略返回值]]></title>
    <url>%2F2018%2F11%2F29%2Ffsockopen%E5%AE%9E%E7%8E%B0%E5%8F%91%E8%B5%B7%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82%E5%BF%BD%E7%95%A5%E8%BF%94%E5%9B%9E%E5%80%BC%2F</url>
    <content type="text"><![CDATA[##前言 前段时间有个需求，我大概描述一下：用户进入公众号或者小程序的所有操作类行为的日志需要后端上报到内部的客户雷达小程序，而且需要异步请求，不需要等待返回。简单来说就是当用户进入小程序点击某件商品或者加入购物车、下单等等操作，上报到雷达小程序，商户会时序看到哪个用户进来我的商店买了哪件商品，浏览了哪些商品，下了多少单等等，都可以随时看到。这个时候我们就可能要需要思考了，要如何做到发起异步请求并且忽略返回值，前端那边不需要等待后端的返回，我也查看过相关资料，最后参考了下面这种方法。 发起异步请求 忽略返回值（后端技术PHP） 自己封装一个方法吧 我直接上代码 1234567891011121314151617181920212223242526272829/** * 发起异步请求，忽略返回值 * @param $url 上报地址 例如http://www.binzhizhu.top * @param array $params 上报的参数 * @return bool */public static function asyncPost($url, $params = [])&#123; Yii::info(&quot;into asyncPost &quot;, __METHOD__); $args = parse_url($url); $host = $args[&apos;host&apos;]; //域名 $path = $args[&apos;path&apos;] . &apos;?&apos; . http_build_query($params);//上报的参数 $fp = fsockopen($host, 80, $error_code, $error_msg, 1);//使用fsockopen方法发起异步请求 if (!$fp) &#123; Yii::error($error_code . &apos; _ &apos; . $error_msg, __METHOD__); return false; &#125; else &#123; stream_set_blocking($fp, true);//开启了手册上说的非阻塞模式 stream_set_timeout($fp, 1);//设置超时 $header = &quot;GET $path HTTP/1.1\r\n&quot;; // GET/POST请求 http1.1协议 $header .= &quot;Host: $host\r\n&quot;; $header .= &quot;Connection: close\r\n\r\n&quot;;//长连接关闭 fwrite($fp, $header); fclose($fp); &#125;&#125;]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Http</tag>
        <tag>Php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Axios--基于 promise 的 HTTP 库]]></title>
    <url>%2F2018%2F11%2F28%2FAxios-%E5%9F%BA%E4%BA%8E-promise-%E7%9A%84-HTTP-%E5%BA%93%2F</url>
    <content type="text"><![CDATA[##认识Axios Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。 Features 从浏览器中创建 XMLHttpRequests 从 node.js 创建 http 请求 支持 Promise API 拦截请求和响应 转换请求数据和响应数据 取消请求 自动转换 JSON 数据 客户端支持防御 XSRF 安装使用 npm: 1$ npm install axios 使用 bower: 1$ bower install axios 使用cdn: 1&lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt; Example ###执行 Get 请求 123456789101112131415161718192021为给定 ID 的 user 创建请求axios.get(&apos;/user?ID=12345&apos;) .then(function (response) &#123; console.log(response); &#125;) .catch(function (error) &#123; console.log(error); &#125;); 可选地，上面的请求可以这样做axios.get(&apos;/user&apos;, &#123; params: &#123; ID: 12345 &#125; &#125;) .then(function (response) &#123; console.log(response); &#125;) .catch(function (error) &#123; console.log(error); &#125;); ###执行 POST 请求 axios.post(&apos;/user&apos;, { firstName: &apos;Fred&apos;, lastName: &apos;Flintstone&apos; }) .then(function (response) { console.log(response); }) .catch(function (error) { console.log(error); }); ###执行多个并发请求 function getUserAccount() { return axios.get(‘/user/12345’); } function getUserPermissions() { return axios.get(‘/user/12345/permissions’); } axios.all([getUserAccount(), getUserPermissions()]) .then(axios.spread(function (acct, perms) { 两个请求现在都执行完成 })); axios API 可以通过向 axios 传递相关配置来创建请求 axios(config) // 发送 POST 请求 axios({ method: ‘post’, url: ‘/user/12345’, data: { firstName: ‘Fred’, lastName: ‘Flintstone’ } }); axios(url[, config]) // 发送 GET 请求（默认的方法） axios(‘/user/12345’); 请求方法的别名 为方便起见，为所有支持的请求方法提供了别名 axios.request(config) axios.get(url[, config]) axios.delete(url[, config]) axios.head(url[, config]) axios.post(url[, data[, config]]) axios.put(url[, data[, config]]) axios.patch(url[, data[, config]]) 在使用别名方法时， url、method、data 这些属性都不必在配置中指定。 并发 处理并发请求的助手函数 axios.all(iterable) axios.spread(callback) 创建实例 以使用自定义配置新建一个 axios 实例 axios.create([config]) var instance = axios.create({ baseURL: ‘https://some-domain.com/api/&#39;, timeout: 1000, headers: {‘X-Custom-Header’: ‘foobar’} }); 实例方法 以下是可用的实例方法。指定的配置将与实例的配置合并 axios#request(config) axios#get(url[, config]) axios#delete(url[, config]) axios#head(url[, config]) axios#post(url[, data[, config]]) axios#put(url[, data[, config]]) axios#patch(url[, data[, config]]) 请求配置 这些是创建请求时可以用的配置选项。只有 url 是必需的。如果没有指定 method，请求将默认使用 get 方法。 { // url 是用于请求的服务器 URL url: ‘/user’, // `method` 是创建请求时使用的方法 method: &apos;get&apos;, // 默认是 get // `baseURL` 将自动加在 `url` 前面，除非 `url` 是一个绝对 URL。 // 它可以通过设置一个 `baseURL` 便于为 axios 实例的方法传递相对 URL baseURL: &apos;https://some-domain.com/api/&apos;, // `transformRequest` 允许在向服务器发送前，修改请求数据 // 只能用在 &apos;PUT&apos;, &apos;POST&apos; 和 &apos;PATCH&apos; 这几个请求方法 // 后面数组中的函数必须返回一个字符串，或 ArrayBuffer，或 Stream transformRequest: [function (data) { // 对 data 进行任意转换处理 return data; }], // `transformResponse` 在传递给 then/catch 前，允许修改响应数据 transformResponse: [function (data) { // 对 data 进行任意转换处理 return data; }], // `headers` 是即将被发送的自定义请求头 headers: {&apos;X-Requested-With&apos;: &apos;XMLHttpRequest&apos;}, // `params` 是即将与请求一起发送的 URL 参数 // 必须是一个无格式对象(plain object)或 URLSearchParams 对象 params: { ID: 12345 }, // `paramsSerializer` 是一个负责 `params` 序列化的函数 // (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/) paramsSerializer: function(params) { return Qs.stringify(params, {arrayFormat: &apos;brackets&apos;}) }, // `data` 是作为请求主体被发送的数据 // 只适用于这些请求方法 &apos;PUT&apos;, &apos;POST&apos;, 和 &apos;PATCH&apos; // 在没有设置 `transformRequest` 时，必须是以下类型之一： // - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams // - 浏览器专属：FormData, File, Blob // - Node 专属： Stream data: { firstName: &apos;Fred&apos; }, // `timeout` 指定请求超时的毫秒数(0 表示无超时时间) // 如果请求话费了超过 `timeout` 的时间，请求将被中断 timeout: 1000, // `withCredentials` 表示跨域请求时是否需要使用凭证 withCredentials: false, // 默认的 // `adapter` 允许自定义处理请求，以使测试更轻松 // 返回一个 promise 并应用一个有效的响应 (查阅 [response docs](#response-api)). adapter: function (config) { /* ... */ }, // `auth` 表示应该使用 HTTP 基础验证，并提供凭据 // 这将设置一个 `Authorization` 头，覆写掉现有的任意使用 `headers` 设置的自定义 `Authorization`头 auth: { username: &apos;janedoe&apos;, password: &apos;s00pers3cret&apos; }, // `responseType` 表示服务器响应的数据类型，可以是 &apos;arraybuffer&apos;, &apos;blob&apos;, &apos;document&apos;, &apos;json&apos;, &apos;text&apos;, &apos;stream&apos; responseType: &apos;json&apos;, // 默认的 // `xsrfCookieName` 是用作 xsrf token 的值的cookie的名称 xsrfCookieName: &apos;XSRF-TOKEN&apos;, // default // `xsrfHeaderName` 是承载 xsrf token 的值的 HTTP 头的名称 xsrfHeaderName: &apos;X-XSRF-TOKEN&apos;, // 默认的 // `onUploadProgress` 允许为上传处理进度事件 onUploadProgress: function (progressEvent) { // 对原生进度事件的处理 }, // `onDownloadProgress` 允许为下载处理进度事件 onDownloadProgress: function (progressEvent) { // 对原生进度事件的处理 }, // `maxContentLength` 定义允许的响应内容的最大尺寸 maxContentLength: 2000, // `validateStatus` 定义对于给定的HTTP 响应状态码是 resolve 或 reject promise 。如果 `validateStatus` 返回 `true` (或者设置为 `null` 或 `undefined`)，promise 将被 resolve; 否则，promise 将被 rejecte validateStatus: function (status) { return status &gt;= 200 &amp;&amp; status &lt; 300; // 默认的 }, // `maxRedirects` 定义在 node.js 中 follow 的最大重定向数目 // 如果设置为0，将不会 follow 任何重定向 maxRedirects: 5, // 默认的 // `httpAgent` 和 `httpsAgent` 分别在 node.js 中用于定义在执行 http 和 https 时使用的自定义代理。允许像这样配置选项： // `keepAlive` 默认没有启用 httpAgent: new http.Agent({ keepAlive: true }), httpsAgent: new https.Agent({ keepAlive: true }), // &apos;proxy&apos; 定义代理服务器的主机名称和端口 // `auth` 表示 HTTP 基础验证应当用于连接代理，并提供凭据 // 这将会设置一个 `Proxy-Authorization` 头，覆写掉已有的通过使用 `header` 设置的自定义 `Proxy-Authorization` 头。 proxy: { host: &apos;127.0.0.1&apos;, port: 9000, auth: : { username: &apos;mikeymike&apos;, password: &apos;rapunz3l&apos; } }, // `cancelToken` 指定用于取消请求的 cancel token // （查看后面的 Cancellation 这节了解更多） cancelToken: new CancelToken(function (cancel) { }) } 响应结构 某个请求的响应包含以下信息 { // data 由服务器提供的响应 data: {}, // `status` 来自服务器响应的 HTTP 状态码 status: 200, // `statusText` 来自服务器响应的 HTTP 状态信息 statusText: &apos;OK&apos;, // `headers` 服务器响应的头 headers: {}, // `config` 是为请求提供的配置信息 config: {} } 使用 then 时，你将接收下面这样的响应： axios.get(‘/user/12345’) .then(function(response) { console.log(response.data); console.log(response.status); console.log(response.statusText); console.log(response.headers); console.log(response.config); }); 在使用 catch 时，或传递 rejection callback 作为 then 的第二个参数时，响应可以通过 error 对象可被使用，正如在错误处理这一节所讲。 配置的默认值/defaults 你可以指定将被用在各个请求的配置默认值 全局的 axios 默认值 axios.defaults.baseURL = ‘https://api.example.com&#39;; axios.defaults.headers.common[‘Authorization’] = AUTH_TOKEN; axios.defaults.headers.post[‘Content-Type’] = ‘application/x-www-form-urlencoded’; 自定义实例默认值 // 创建实例时设置配置的默认值 var instance = axios.create({ baseURL: ‘https://api.example.com&#39; }); // 在实例已创建后修改默认值 instance.defaults.headers.common[‘Authorization’] = AUTH_TOKEN; 配置的优先顺序 配置会以一个优先顺序进行合并。这个顺序是：在 lib/defaults.js 找到的库的默认值，然后是实例的 defaults 属性，最后是请求的 config 参数。后者将优先于前者。这里是一个例子： // 使用由库提供的配置的默认值来创建实例 // 此时超时配置的默认值是 0 var instance = axios.create(); // 覆写库的超时默认值 // 现在，在超时前，所有请求都会等待 2.5 秒 instance.defaults.timeout = 2500; // 为已知需要花费很长时间的请求覆写超时设置 instance.get(‘/longRequest’, { timeout: 5000 }); 拦截器 在请求或响应被 then 或 catch 处理前拦截它们: // 添加请求拦截器 axios.interceptors.request.use(function (config) { // 在发送请求之前做些什么 return config; }, function (error) { // 对请求错误做些什么 return Promise.reject(error); }); // 添加响应拦截器 axios.interceptors.response.use(function (response) { // 对响应数据做点什么 return response; }, function (error) { // 对响应错误做点什么 return Promise.reject(error); }); 如果你想在稍后移除拦截器，可以这样： var myInterceptor = axios.interceptors.request.use(function () {/…/}); axios.interceptors.request.eject(myInterceptor); 可以为自定义 axios 实例添加拦截器 var instance = axios.create(); instance.interceptors.request.use(function () {/…/}); 错误处理 axios.get(‘/user/12345’) .catch(function (error) { if (error.response) { // 请求已发出，但服务器响应的状态码不在 2xx 范围内 console.log(error.response.data); console.log(error.response.status); console.log(error.response.headers); } else { // Something happened in setting up the request that triggered an Error console.log(‘Error’, error.message); } console.log(error.config); }); 可以使用 validateStatus 配置选项定义一个自定义 HTTP 状态码的错误范围。 axios.get(‘/user/12345’, { validateStatus: function (status) { return status &lt; 500; // 状态码在大于或等于500时才会 reject } }) 取消 使用 cancel token 取消请求 Axios 的 cancel token API 基于cancelable promises proposal，它还处于第一阶段。 可以使用 CancelToken.source 工厂方法创建 cancel token，像这样： var CancelToken = axios.CancelToken; var source = CancelToken.source(); axios.get(‘/user/12345’, { cancelToken: source.token }).catch(function(thrown) { if (axios.isCancel(thrown)) { console.log(‘Request canceled’, thrown.message); } else { // 处理错误 } }); // 取消请求（message 参数是可选的） source.cancel(‘Operation canceled by the user.’); 还可以通过传递一个 executor 函数到 CancelToken 的构造函数来创建 cancel token： var CancelToken = axios.CancelToken; var cancel; axios.get(‘/user/12345’, { cancelToken: new CancelToken(function executor(c) { // executor 函数接收一个 cancel 函数作为参数 cancel = c; }) }); // 取消请求 cancel(); tip : 可以使用同一个 cancel token 取消多个请求 Promises axios 依赖原生的 ES6 Promise 实现而被支持. 如果你的环境不支持 ES6 Promise，你可以使用 polyfill. TypeScript axios includes TypeScript definitions import axios from &apos;axios&apos;; axios.get(&apos;/user?ID=12345&apos;); 文章引用链接 [kancloud]: https://www.kancloud.cn/yunye/axios [GitHub Axios]: https://github.com/axios/axios [Axios API]: https://cn.vuejs.org/v2/cookbook/using-axios-to-consume-apis.html]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>axios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx 配置访问Access Denied]]></title>
    <url>%2F2018%2F11%2F21%2FNginx-%E9%85%8D%E7%BD%AE%E8%AE%BF%E9%97%AEAccess-Denied%2F</url>
    <content type="text"><![CDATA[前言 前段时间双11阿里云搞活动，于是便忍痛（花呗）入手了一台1核2G、40G系统盘、1M带宽的云服务ECS服务器。想着自己平时开发玩玩以及搭建自己的博客，所以就很爽快的买了，还顺便在阿里云买了一个.top的域名。也就是博客现在的这个域名，域名申请备案后，大概半个月左右收到备案通过的通知，于是我就开始解析域名到服务器，同时也把自己的项目在服务器搭建好。我是直接搭wget一键安装LNMP环境的，github clone下来，这个时候心想着配置一下虚拟域名应该就美滋滋了。 搭建过程的遇到的问题访问解析的域名连接重置 我刚开始以为是域名解析的问题，因为访问域名是一直显示正在连接，最后显示连接重置，也就是说无法连接到服务器，于是我问了一下其他朋友，在阿里云服务器添加了安全组，默认开启所有连接。其实开启http 80、https就可以了，其他看自己的需求，添加之后就不会显示连接重置了。 访问提示Access Denied 1access denied mlgj… 难受，解决了一个问题又出现了另外一个问题，访问项目提示access denied。我前前后后检查过Nginx的配置，真的觉得没有问题…。Nginx 提示successful，重启也正常。最让我觉得奇怪的是，访问域名提示access denied 的同时，可以看到网页的logo 已经访问到我项目的logo了，但是就完全没有任何反应，我自己去看Nginx日志也没相应的报错信息，我真的不知道该如何排查。 重新clone项目部署 我只好重新clone项目 重新认真部署一次 看看效果如何 未完待续。。。]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue.js结合ElementUI的（分页）进行前端分页]]></title>
    <url>%2F2018%2F11%2F17%2FVue-js%E7%BB%93%E5%90%88ElementUI%E7%9A%84%EF%BC%88%E5%88%86%E9%A1%B5%EF%BC%89%E8%BF%9B%E8%A1%8C%E5%89%8D%E7%AB%AF%E5%88%86%E9%A1%B5%2F</url>
    <content type="text"><![CDATA[前言 我们在开发的过程中总会遇到某些项目需要根据后台接口返回的数据进行前端分页显示，举个例子：电商项目中的订单列表页面。后台点击订单列表页的时候会去请求后端接口，前端根据后端返回的订单数据进行分页显示。虽然自己是一个后端人员，但今天处理一个后台改版的任务的时候，订单列表页用Vue写的，在对接写好的接口的时候，就遇到了这个分页的问题。那我们就一起来看下这个问题一般要如何解决吧。 思路 大致的想法是：后台返回所有订单数据，然后前端拿到返回的数据进行全部分页，这里注意的是：例如有100条记录，每页显示10条，这个时候实际分页效果是10页对吧，也就是说我们是后端一次性返回所有的订单数据，然后交给前端提前进行分页，每一页的数据我们在拿到后台返回的数据的时候前端就已经分好页了。 优点 分页切换的效果用户体验会更加顺畅； 当删除一条数据的时候过滤器会重新计算当前页面的显示数据 缺点 当页面数据量大的时候会浪费很多流量，因为有点类似于预加载的效果，一次把所有数据返回，数据多的时候RT时间会比较长 代码片段过滤器 我们应该先创建一个过滤器来过滤列表数据，这里有三个参数tabledata（列表数据），pageNum（当前第几页），pagesize（每页条数） 1234567filters:&#123; pagination(tabledata,pageNum,pagesize)&#123; let offset = (pageNum - 1) * pagesize;//当前页第一条的索引 let data=(offset + pagesize &gt;= tabledata.length) ? array.slice(offset, tabledata.length) : array.slice(offset, offset + pagesize); return data &#125; &#125; 完整代码 1234567891011121314151617&lt;template&gt; &lt;el-table :data=&quot;tableData | pagination(pageNum,pagesize)&quot;&gt; &lt;el-table-column label=&quot;&quot;&gt; &lt;template slot-scope=&quot;scope&quot;&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;/el-table&gt; &lt;el-pagination @size-change=&quot;handleSizeChange&quot; @current-change=&quot;handleCurrentChange&quot; :current-page=&quot;pageNo&quot; :page-size=&quot;pageSize&quot; layout=&quot; prev, pager, next, sizes, jumper&quot; :total=&quot;tableData.length&quot;&gt; &lt;/el-pagination&gt;&lt;/template&gt; 上面是elementui 的pagination 分页组件代码片段，不理解的直接去看文档即可 12345678910111213141516171819202122232425262728293031&lt;script&gt; export default&#123; data()&#123; return &#123; tableData: [&#123; id:&apos;&apos;, name:&apos;&apos;, &#125;], pagenum: 1, pagesize:10 &#125; &#125;, methods:&#123; handleSizeChange(val) &#123; console.log(`每页 $&#123;val&#125; 条`); this.pagesize=val; &#125;, handleCurrentChange(val) &#123; console.log(`当前页: $&#123;val&#125;`); this.pageNum = val; &#125; &#125;, filters:&#123; pagination(tabledata,pageNum,pagesize)&#123; let offset = (pageNum - 1) * pagesize;//当前页第一条的索引 let data=(offset + pagesize &gt;= tabledata.length) ? array.slice(offset, tabledata.length) : array.slice(offset, offset + pagesize); return data &#125; &#125; &#125;&lt;/script&gt; 总结：这种做法就比较舒服，用户体验也很好，切换分页的时候会很流畅。但还有另外的做法就是通过单页数据返回，每一次切换分页的时候去请求当前这个页面的数据，但是这种做法需要自己写上一页、下一页的方法，用户点击的时候去请求当前页面的数据去渲染，并不是一次性返回所有数据，这也是这种方法的优势，总的来说还得看具体的业务场景。 最后当然要贴一波效果图啊]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决Hexo首页阅读次数样式诡异的问题]]></title>
    <url>%2F2018%2F11%2F16%2F%E8%A7%A3%E5%86%B3Hexo%E9%A6%96%E9%A1%B5%E9%98%85%E8%AF%BB%E6%AC%A1%E6%95%B0%E6%A0%B7%E5%BC%8F%E8%AF%A1%E5%BC%82%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[前言 今晚在完善阅读统计的功能是时候发现一个很诡异的问题，我们一起来探讨一下。上一篇文章大概有阐述阅读统计功能的搭建，所有这里我就不多说了。 利用leancloud接完统计功能后，当前这个hexo版本我会发现首页的阅读数量的样式有点诡异，大致如下： 两种情况： 1：阅读次数::9:9 :2：阅读次数::99 实际上这个时候我们的阅读量只有9而已，正常来说应该这样显示： 阅读次数：9 于是我忍不住摁住F12一探究竟,大致可以知道阅读次数那一块的元素是js直接赋值的，所以我就去找了一下阅读统计的部分的相关js，我比较粗暴，直接定位全局搜索一波 leancloud_visitors 相关的文件 这是我们可以找到一个路径为 themes\next\layout_third-party\analytics\lean-analytics.swig 的文件，打开发现就是这部分js处理leancloud的阅读数量统计。 贴一波阅读次数统计的代码(LeanCloud提供支持) 看到function showTime 我相信你已经很明白了123456789101112131415161718192021222324252627282930313233&#123;% if theme.leancloud_visitors.enable %&#125; &#123;# custom analytics part create by xiamo #&#125; &lt;script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"&gt;&lt;/script&gt; &lt;script&gt;AV.initialize("&#123;&#123;theme.leancloud_visitors.app_id&#125;&#125;", "&#123;&#123;theme.leancloud_visitors.app_key&#125;&#125;");&lt;/script&gt; &lt;script&gt; function showTime(Counter) &#123; console.warn('~欢迎光临我的博客 Email:binzhizhu@gmail.com ') var query = new AV.Query(Counter); $(".leancloud_visitors").each(function() &#123; var url = $(this).attr("id").trim(); query.equalTo("url", url); query.find(&#123; success: function(results) &#123; console.warn('--这里是阅读统计代码-- by --leancloud--') if (results.length == 0) &#123; var content = $(document.getElementById(url)).text() + ': 0'; $(document.getElementById(url)).text(content); return; &#125; for (var i = 0; i &lt; results.length; i++) &#123; var object = results[i]; var content = $(document.getElementById(url)).text() + object.attributes.time; $(document.getElementById(url)).text(content); &#125; &#125;, error: function(object, error) &#123; console.log("Error: " + error.code + " " + error.message); &#125; &#125;); &#125;); &#125; 上述代码中的 for循环，看起来是没任何问题。但我hexo g -d 到GitHubPage 的时候，我再for循环里面console.log(‘obj’,object),打印了一下当前文章的所有属性，发现同一篇文章会打印两次，所有才会出现上面所说的 阅读次数::99的情况。相当于第一次循环time是9，循环了两次拼接了起来于是变成阅读次数::99 所有我 直接在for循环的最后加了一句 1return; 真.阅读统计代码段 这么做实际上很简单，类似于做一层兼容了，确保不会重复循环，修复了之后发现真的没有问题了，阅读次数显示正常了，美滋滋，这也是一种收获。顺便也贴一下其他阅读统计事件的代码片段吧： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253 function addCount(Counter) &#123; var Counter = AV.Object.extend(&quot;Counter&quot;); url = $(&quot;.leancloud_visitors&quot;).attr(&apos;id&apos;).trim(); title = $(&quot;.leancloud_visitors&quot;).attr(&apos;data-flag-title&apos;).trim(); var query = new AV.Query(Counter); query.equalTo(&quot;url&quot;, url); query.find(&#123; success: function(results) &#123; if (results.length &gt; 0) &#123; var counter = results[0]; counter.fetchWhenSave(true); counter.increment(&quot;time&quot;); counter.save(null, &#123; success: function(counter) &#123; var content = $(document.getElementById(url)).text() + &apos;: &apos; + counter.get(&apos;time&apos;); $(document.getElementById(url)).text(content); &#125;, error: function(counter, error) &#123; console.log(&apos;Failed to save Visitor num, with error message: &apos; + error.message); &#125; &#125;); &#125; else &#123; var newcounter = new Counter(); newcounter.set(&quot;title&quot;, title); newcounter.set(&quot;url&quot;, url); newcounter.set(&quot;time&quot;, 1); newcounter.save(null, &#123; success: function(newcounter) &#123; console.log(&quot;newcounter.get(&apos;time&apos;)=&quot;+newcounter.get(&apos;time&apos;)); var content = $(document.getElementById(url)).text() + &apos;: &apos; + newcounter.get(&apos;time&apos;); $(document.getElementById(url)).text(content); &#125;, error: function(newcounter, error) &#123; console.log(&apos;Failed to create&apos;); &#125; &#125;); &#125; &#125;, error: function(error) &#123; console.log(&apos;Error:&apos; + error.code + &quot; &quot; + error.message); &#125; &#125;); &#125; $(function() &#123; var Counter = AV.Object.extend(&quot;Counter&quot;); if ($(&apos;.leancloud_visitors&apos;).length == 1) &#123; addCount(Counter); &#125; else if ($(&apos;.post-title-link&apos;).length &gt; 1) &#123; showTime(Counter); &#125; &#125;); &lt;/script&gt;&#123;% endif %&#125; 这篇博客写得我有点疲惫了，已经深夜十分了，准备入睡啦，明天还要起来搬砖呢，晚安各位，希望能够帮助到大家吧，我也是刚学习Hexo自己搭建博客。 但有趣的一点是我们可以在这些开源的框架或者资源里面肆意的玩弄代码，hexo其实就是提供给大家开源开发的，看着文档接服务就好了，一大推的第三方服务已经Api。 最后发一个今天的自拍吧 哈哈哈！！！]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为NexT主题添加文章阅读量统计功能]]></title>
    <url>%2F2018%2F11%2F15%2F%E4%B8%BANexT%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E9%87%8F%E7%BB%9F%E8%AE%A1%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[前言最近刚入门Hexo+GithubPage搭建个人博客，基础的搭建完毕之后，总觉得缺少些技术性（代表）的功能，于是想到要不要在自己的博客搭建阅读统计的功能？但这个时候不太明白如何去实现，网上看了其他博主的一些建议之后，也打算使用learncloud这家服务商的资源解决我们的问题，所以我们得先去learncloud官网注册账号。]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[尝试使用Hexo+Github搭建个人博客]]></title>
    <url>%2F2018%2F11%2F14%2F%E5%B0%9D%E8%AF%95%E4%BD%BF%E7%94%A8Hexo-Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[##初探Hexo Hexo是一款基于Node.js的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在GitHub和Heroku上，是搭建博客的首选框架。这里我们选用的是GitHub，你没看错，全球最大的同性恋交友网站（逃……）。Hexo同时也是GitHub上的开源项目，参见：hexojs/hexo 如果想要更加全面的了解Hexo，可以到其官网 Hexo 了解更多的细节，因为Hexo的创建者是台湾人，对中文的支持很友好，可以选择中文进行查看。这里，默认各位猿/媛儿都知道GitHub就不再赘述。 ##搭建步骤 1.获得个人网站域名2.GitHub创建个人仓库3.安装Git4.安装Node.js5.安装Hexo6.推送网站7.绑定域名8.更换主题9.初识MarkDown语法10.发布文章11.寻找图床12.个性化设置 ##关于博主 本人博客地址：https://binzhizhu.github.io交流：binzhizhu@gmail.com网站：www.binzhizhu.top]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[北岛-《回答》]]></title>
    <url>%2F2018%2F11%2F14%2F%E5%8C%97%E5%B2%9B-%E3%80%8A%E5%9B%9E%E7%AD%94%E3%80%8B%2F</url>
    <content type="text"><![CDATA[回答 卑鄙是卑鄙者的通行证，高尚是高尚者的墓志铭，看吧，在那镀金的天空中，飘满了死者弯曲的倒影。冰川纪过去了，为什么到处都是冰凌？好望角发现了，为什么死海里千帆相竞？我来到这个世界上，只带着纸、绳索和身影，为了在审判之前，宣读那些被判决的声音。告诉你吧，世界我–不–相–信！纵使你脚下有一千名挑战者，那就把我算作第一千零一名。我不相信天是蓝的，我不相信雷的回声，我不相信梦是假的，我不相信死无报应。如果海洋注定要决堤，就让所有的苦水都注入我心中，如果陆地注定要上升，就让人类重新选择生存的峰顶。新的转机和闪闪星斗，正在缀满没有遮拦的天空。那是五千年的象形文字，那是未来人们凝视的眼睛。]]></content>
      <categories>
        <category>精神食物</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
</search>
