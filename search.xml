<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Nginx 配置访问Access Denied]]></title>
    <url>%2F2018%2F11%2F21%2FNginx-%E9%85%8D%E7%BD%AE%E8%AE%BF%E9%97%AEAccess-Denied%2F</url>
    <content type="text"><![CDATA[前言 前段时间双11阿里云搞活动，于是便忍痛（花呗）入手了一台1核2G、40G系统盘、1M带宽的云服务ECS服务器。想着自己平时开发玩玩以及搭建自己的博客，所以就很爽快的买了，还顺便在阿里云买了一个.top的域名。也就是博客现在的这个域名，域名申请备案后，大概半个月左右收到备案通过的通知，于是我就开始解析域名到服务器，同时也把自己的项目在服务器搭建好。我是直接搭wget一键安装LNMP环境的，github clone下来，这个时候心想着配置一下虚拟域名应该就美滋滋了。 搭建过程的遇到的问题访问解析的域名连接重置 我刚开始以为是域名解析的问题，因为访问域名是一直显示正在连接，最后显示连接重置，也就是说无法连接到服务器，于是我问了一下其他朋友，在阿里云服务器添加了安全组，默认开启所有连接。其实开启http 80、https就可以了，其他看自己的需求，添加之后就不会显示连接重置了。 访问提示Access Denied 1access denied mlgj… 难受，解决了一个问题又出现了另外一个问题，访问项目提示access denied。我前前后后检查过Nginx的配置，真的觉得没有问题…。Nginx 提示successful，重启也正常。最让我觉得奇怪的是，访问域名提示access denied 的同时，可以看到网页的logo 已经访问到我项目的logo了，但是就完全没有任何反应，我自己去看Nginx日志也没相应的报错信息，我真的不知道该如何排查。 重新clone项目部署 我只好重新clone项目 重新认真部署一次 看看效果如何 未完待续。。。]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue.js结合ElementUI的（分页）进行前端分页]]></title>
    <url>%2F2018%2F11%2F17%2FVue-js%E7%BB%93%E5%90%88ElementUI%E7%9A%84%EF%BC%88%E5%88%86%E9%A1%B5%EF%BC%89%E8%BF%9B%E8%A1%8C%E5%89%8D%E7%AB%AF%E5%88%86%E9%A1%B5%2F</url>
    <content type="text"><![CDATA[前言 我们在开发的过程中总会遇到某些项目需要根据后台接口返回的数据进行前端分页显示，举个例子：电商项目中的订单列表页面。后台点击订单列表页的时候会去请求后端接口，前端根据后端返回的订单数据进行分页显示。虽然自己是一个后端人员，但今天处理一个后台改版的任务的时候，订单列表页用Vue写的，在对接写好的接口的时候，就遇到了这个分页的问题。那我们就一起来看下这个问题一般要如何解决吧。 思路 大致的想法是：后台返回所有订单数据，然后前端拿到返回的数据进行全部分页，这里注意的是：例如有100条记录，每页显示10条，这个时候实际分页效果是10页对吧，也就是说我们是后端一次性返回所有的订单数据，然后交给前端提前进行分页，每一页的数据我们在拿到后台返回的数据的时候前端就已经分好页了。 优点 分页切换的效果用户体验会更加顺畅； 当删除一条数据的时候过滤器会重新计算当前页面的显示数据 缺点 当页面数据量大的时候会浪费很多流量，因为有点类似于预加载的效果，一次把所有数据返回，数据多的时候RT时间会比较长 代码片段过滤器 我们应该先创建一个过滤器来过滤列表数据，这里有三个参数tabledata（列表数据），pageNum（当前第几页），pagesize（每页条数） 1234567filters:&#123; pagination(tabledata,pageNum,pagesize)&#123; let offset = (pageNum - 1) * pagesize;//当前页第一条的索引 let data=(offset + pagesize &gt;= tabledata.length) ? array.slice(offset, tabledata.length) : array.slice(offset, offset + pagesize); return data &#125; &#125; 完整代码 1234567891011121314151617&lt;template&gt; &lt;el-table :data=&quot;tableData | pagination(pageNum,pagesize)&quot;&gt; &lt;el-table-column label=&quot;&quot;&gt; &lt;template slot-scope=&quot;scope&quot;&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;/el-table&gt; &lt;el-pagination @size-change=&quot;handleSizeChange&quot; @current-change=&quot;handleCurrentChange&quot; :current-page=&quot;pageNo&quot; :page-size=&quot;pageSize&quot; layout=&quot; prev, pager, next, sizes, jumper&quot; :total=&quot;tableData.length&quot;&gt; &lt;/el-pagination&gt;&lt;/template&gt; 上面是elementui 的pagination 分页组件代码片段，不理解的直接去看文档即可 12345678910111213141516171819202122232425262728293031&lt;script&gt; export default&#123; data()&#123; return &#123; tableData: [&#123; id:&apos;&apos;, name:&apos;&apos;, &#125;], pagenum: 1, pagesize:10 &#125; &#125;, methods:&#123; handleSizeChange(val) &#123; console.log(`每页 $&#123;val&#125; 条`); this.pagesize=val; &#125;, handleCurrentChange(val) &#123; console.log(`当前页: $&#123;val&#125;`); this.pageNum = val; &#125; &#125;, filters:&#123; pagination(tabledata,pageNum,pagesize)&#123; let offset = (pageNum - 1) * pagesize;//当前页第一条的索引 let data=(offset + pagesize &gt;= tabledata.length) ? array.slice(offset, tabledata.length) : array.slice(offset, offset + pagesize); return data &#125; &#125; &#125;&lt;/script&gt; 总结：这种做法就比较舒服，用户体验也很好，切换分页的时候会很流畅。但还有另外的做法就是通过单页数据返回，每一次切换分页的时候去请求当前这个页面的数据，但是这种做法需要自己写上一页、下一页的方法，用户点击的时候去请求当前页面的数据去渲染，并不是一次性返回所有数据，这也是这种方法的优势，总的来说还得看具体的业务场景。 最后当然要贴一波效果图啊]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决Hexo首页阅读次数样式诡异的问题]]></title>
    <url>%2F2018%2F11%2F16%2F%E8%A7%A3%E5%86%B3Hexo%E9%A6%96%E9%A1%B5%E9%98%85%E8%AF%BB%E6%AC%A1%E6%95%B0%E6%A0%B7%E5%BC%8F%E8%AF%A1%E5%BC%82%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[前言 今晚在完善阅读统计的功能是时候发现一个很诡异的问题，我们一起来探讨一下。上一篇文章大概有阐述阅读统计功能的搭建，所有这里我就不多说了。 利用leancloud接完统计功能后，当前这个hexo版本我会发现首页的阅读数量的样式有点诡异，大致如下： 两种情况： 1：阅读次数::9:9 :2：阅读次数::99 实际上这个时候我们的阅读量只有9而已，正常来说应该这样显示： 阅读次数：9 于是我忍不住摁住F12一探究竟,大致可以知道阅读次数那一块的元素是js直接赋值的，所以我就去找了一下阅读统计的部分的相关js，我比较粗暴，直接定位全局搜索一波 leancloud_visitors 相关的文件 这是我们可以找到一个路径为 themes\next\layout_third-party\analytics\lean-analytics.swig 的文件，打开发现就是这部分js处理leancloud的阅读数量统计。 贴一波阅读次数统计的代码(LeanCloud提供支持) 看到function showTime 我相信你已经很明白了123456789101112131415161718192021222324252627282930313233&#123;% if theme.leancloud_visitors.enable %&#125; &#123;# custom analytics part create by xiamo #&#125; &lt;script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"&gt;&lt;/script&gt; &lt;script&gt;AV.initialize("&#123;&#123;theme.leancloud_visitors.app_id&#125;&#125;", "&#123;&#123;theme.leancloud_visitors.app_key&#125;&#125;");&lt;/script&gt; &lt;script&gt; function showTime(Counter) &#123; console.warn('~欢迎光临我的博客 Email:binzhizhu@gmail.com ') var query = new AV.Query(Counter); $(".leancloud_visitors").each(function() &#123; var url = $(this).attr("id").trim(); query.equalTo("url", url); query.find(&#123; success: function(results) &#123; console.warn('--这里是阅读统计代码-- by --leancloud--') if (results.length == 0) &#123; var content = $(document.getElementById(url)).text() + ': 0'; $(document.getElementById(url)).text(content); return; &#125; for (var i = 0; i &lt; results.length; i++) &#123; var object = results[i]; var content = $(document.getElementById(url)).text() + object.attributes.time; $(document.getElementById(url)).text(content); &#125; &#125;, error: function(object, error) &#123; console.log("Error: " + error.code + " " + error.message); &#125; &#125;); &#125;); &#125; 上述代码中的 for循环，看起来是没任何问题。但我hexo g -d 到GitHubPage 的时候，我再for循环里面console.log(‘obj’,object),打印了一下当前文章的所有属性，发现同一篇文章会打印两次，所有才会出现上面所说的 阅读次数::99的情况。相当于第一次循环time是9，循环了两次拼接了起来于是变成阅读次数::99 所有我 直接在for循环的最后加了一句 1return; 真.阅读统计代码段 这么做实际上很简单，类似于做一层兼容了，确保不会重复循环，修复了之后发现真的没有问题了，阅读次数显示正常了，美滋滋，这也是一种收获。顺便也贴一下其他阅读统计事件的代码片段吧： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253 function addCount(Counter) &#123; var Counter = AV.Object.extend(&quot;Counter&quot;); url = $(&quot;.leancloud_visitors&quot;).attr(&apos;id&apos;).trim(); title = $(&quot;.leancloud_visitors&quot;).attr(&apos;data-flag-title&apos;).trim(); var query = new AV.Query(Counter); query.equalTo(&quot;url&quot;, url); query.find(&#123; success: function(results) &#123; if (results.length &gt; 0) &#123; var counter = results[0]; counter.fetchWhenSave(true); counter.increment(&quot;time&quot;); counter.save(null, &#123; success: function(counter) &#123; var content = $(document.getElementById(url)).text() + &apos;: &apos; + counter.get(&apos;time&apos;); $(document.getElementById(url)).text(content); &#125;, error: function(counter, error) &#123; console.log(&apos;Failed to save Visitor num, with error message: &apos; + error.message); &#125; &#125;); &#125; else &#123; var newcounter = new Counter(); newcounter.set(&quot;title&quot;, title); newcounter.set(&quot;url&quot;, url); newcounter.set(&quot;time&quot;, 1); newcounter.save(null, &#123; success: function(newcounter) &#123; console.log(&quot;newcounter.get(&apos;time&apos;)=&quot;+newcounter.get(&apos;time&apos;)); var content = $(document.getElementById(url)).text() + &apos;: &apos; + newcounter.get(&apos;time&apos;); $(document.getElementById(url)).text(content); &#125;, error: function(newcounter, error) &#123; console.log(&apos;Failed to create&apos;); &#125; &#125;); &#125; &#125;, error: function(error) &#123; console.log(&apos;Error:&apos; + error.code + &quot; &quot; + error.message); &#125; &#125;); &#125; $(function() &#123; var Counter = AV.Object.extend(&quot;Counter&quot;); if ($(&apos;.leancloud_visitors&apos;).length == 1) &#123; addCount(Counter); &#125; else if ($(&apos;.post-title-link&apos;).length &gt; 1) &#123; showTime(Counter); &#125; &#125;); &lt;/script&gt;&#123;% endif %&#125; 这篇博客写得我有点疲惫了，已经深夜十分了，准备入睡啦，明天还要起来搬砖呢，晚安各位，希望能够帮助到大家吧，我也是刚学习Hexo自己搭建博客。 但有趣的一点是我们可以在这些开源的框架或者资源里面肆意的玩弄代码，hexo其实就是提供给大家开源开发的，看着文档接服务就好了，一大推的第三方服务已经Api。 最后发一个今天的自拍吧 哈哈哈！！！]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为NexT主题添加文章阅读量统计功能]]></title>
    <url>%2F2018%2F11%2F15%2F%E4%B8%BANexT%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E9%87%8F%E7%BB%9F%E8%AE%A1%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[前言最近刚入门Hexo+GithubPage搭建个人博客，基础的搭建完毕之后，总觉得缺少些技术性（代表）的功能，于是想到要不要在自己的博客搭建阅读统计的功能？但这个时候不太明白如何去实现，网上看了其他博主的一些建议之后，也打算使用learncloud这家服务商的资源解决我们的问题，所以我们得先去learncloud官网注册账号。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[尝试使用Hexo+Github搭建个人博客]]></title>
    <url>%2F2018%2F11%2F14%2F%E5%B0%9D%E8%AF%95%E4%BD%BF%E7%94%A8Hexo-Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[##初探Hexo Hexo是一款基于Node.js的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在GitHub和Heroku上，是搭建博客的首选框架。这里我们选用的是GitHub，你没看错，全球最大的同性恋交友网站（逃……）。Hexo同时也是GitHub上的开源项目，参见：hexojs/hexo 如果想要更加全面的了解Hexo，可以到其官网 Hexo 了解更多的细节，因为Hexo的创建者是台湾人，对中文的支持很友好，可以选择中文进行查看。这里，默认各位猿/媛儿都知道GitHub就不再赘述。 ##搭建步骤 1.获得个人网站域名2.GitHub创建个人仓库3.安装Git4.安装Node.js5.安装Hexo6.推送网站7.绑定域名8.更换主题9.初识MarkDown语法10.发布文章11.寻找图床12.个性化设置 ##关于博主 本人博客地址：https://binzhizhu.github.io交流：binzhizhu@gmail.com网站：www.binzhizhu.top]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[北岛-《回答》]]></title>
    <url>%2F2018%2F11%2F14%2F%E5%8C%97%E5%B2%9B-%E3%80%8A%E5%9B%9E%E7%AD%94%E3%80%8B%2F</url>
    <content type="text"><![CDATA[卑鄙是卑鄙者的通行证，高尚是高尚者的墓志铭，看吧，在那镀金的天空中，飘满了死者弯曲的倒影。 冰川纪过去了，为什么到处都是冰凌？好望角发现了，为什么死海里千帆相竞？ 我来到这个世界上，只带着纸、绳索和身影，为了在审判之前，宣读那些被判决的声音。 告诉你吧，世界我–不–相–信！纵使你脚下有一千名挑战者，那就把我算作第一千零一名。 我不相信天是蓝的，我不相信雷的回声，我不相信梦是假的，我不相信死无报应。 如果海洋注定要决堤，就让所有的苦水都注入我心中，如果陆地注定要上升，就让人类重新选择生存的峰顶。 新的转机和闪闪星斗，正在缀满没有遮拦的天空。那是五千年的象形文字，那是未来人们凝视的眼睛。]]></content>
      <categories>
        <category>诗</category>
      </categories>
      <tags>
        <tag>现代诗</tag>
        <tag>朦胧诗</tag>
        <tag>感悟</tag>
      </tags>
  </entry>
</search>
