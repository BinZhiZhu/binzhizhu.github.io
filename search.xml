<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[教你用认知和人性来做最棒的程序员]]></title>
    <url>%2F2019%2F01%2F19%2F%E6%95%99%E4%BD%A0%E7%94%A8%E8%AE%A4%E7%9F%A5%E5%92%8C%E4%BA%BA%E6%80%A7%E6%9D%A5%E5%81%9A%E6%9C%80%E6%A3%92%E7%9A%84%E7%A8%8B%E5%BA%8F%E5%91%98%2F</url>
    <content type="text"><![CDATA[分享 今天早上在掘金社区看到一篇文章“教你用认知和人性来做最棒的程序员”，我觉得文章写的不错，也让我产生了一些共鸣， 于是想跟大家一起分享一下，已经通过作者的许可，也会贴出文章的原地址。 前言不久前，在团队内部和大家做了一次分享，内容就是这次要讲的“用认知和人性来提升自己的技术水平”，大家反响不错，所以这次整理一下也分享给大家。最初我是想用“借优秀的产品经理思维来做最棒程序员”的这个标题，但想想还是要有同理心，技术同学平时和产品同学已经是相爱相杀了，就不刺激大家啦。但是必须要说的是优秀的产品经理思维和优秀的程序员思维确实是殊途同归的，两者是想通的，就是来自认知和人性。 概念这里我不会过多去梳理认知和人性的概念，后面会用很多例子来说明，保证通俗易懂，只想先提2个概念： 对人性的理解能帮助提升认知 狭义的技术是指java,php,android,spring,vue等的掌握和实践，它们只是帮助你提升认知的工具，却绝不等同于认知。 下面我来逐一举例说明： 例子1-技术选型 问题：今年开始慢慢火的一个移动端跨平台技术是google发布的”flutter”，如果你作为一名移动端的开发人员来评估这门技术是否值得选型作为公司产品的语言框架，你怎么能保证评估不会看走眼？ 认知：flutter强化了跨平台的生产效率，且性能比前端框架更好。 解释：很多同学会想，怎么第一句感觉就像废话一样，人家官方文档也是这么写的，这叫什么认知。别急，所谓的认知，就是能够提炼成外人看上去貌似一句很普通的话，但只有经过深度思考的你才知道它真正的价值。在flutter没有出现前，我存在一个认知偏差，我认为客户端一定会被前端诸如react，vue这样的技术取代。因为它们既可以跨平台，也可以随时更新，符合互联网快速变化的节奏。但我的认知存在一个非常严重的漏洞，那就是跨平台和随时更新在客户端技术里的占比各应该是多少？哪个更重要？经过分析思考，以我们公司当前用户量的发展阶段，提升跨平台的生产效率且不损失太多性能更重要，所谓的运营快速需求变化有时候可以通过事先想清楚，而降低频率。flutter带来的生产效率提升，不仅仅是一个开发可以同时产出android和ios两端应用。更在于产品经理以后只需要和一个开发沟通需求细节，不会再担心出现android和ios功能细节实现偏差的问题了。由于有了这样的认知，虽然flutter作为新技术，还有需要完善的地方。但这不是主要问题，我们愿意为它去冒险，在我们的产品里去尽快实践。 人性：最后多说一句，为什么google先做了kotlin后又做了flutter呢？我的认知是：大公司两个部门做重复轮子很正常，互相竞争，看谁更好。一个想试探性取代java以避免被oracle捏住命脉（如果接受的人多，将来把底层的jvm再抽掉），一个野心更大希望统一所有平台，不同部门的想法而已。大家不要把google的布局想得那么纯粹技术化，大家都是人嘛。人脱离不了：竞争，征服，自保的人性。:) 例子2-查线上问题 问题：觉得查线上问题很痛苦，压力很大，查得也不快怎么办？ 认知：1 查线上问题是成本最小的，锻炼逻辑思维的方式，相比写代码更有效率。 2 查问题要看本质，抓住案发第一现场 解释：很多同学碰到线上问题的时候，都很痛苦，因为要加班了耽误我学习技术的时间，所以有时查问题态度也不积极。这个认知是非常错误的，大家平时都会认可优秀程序员的核心特质看的是思维逻辑，而不是用哪个语言哪个技术。那如果是思维逻辑优先，写代码就能比查线上问题更能提升吗？显然不是，大家知道我们在写代码时，往往要花费很多时间在编写冗余代码（如get,set代码，配置文件），普通的crud逻辑，编译，部署等这些非核心点上，它们并不能帮助我们提升思维（动手写代码前的思考才是最核心的）。但是查线上问题就不一样了，你不需要写任何代码，但是需要在很短时间内，让自己理清思路，按正确的步骤去查出代码的核心问题，底层系统的核心问题。你需要对系统很了解，对业务逻辑很了解，对代码细节很了解，这真是一个几乎没有任何冗余步骤，但是却能快速提升严谨思维的好方式！怎么让查问题更有效率？其实很简单，我们如果借鉴名侦探柯南的想法，那就是“抓住案发第一现场”。举两个例子，对于JAVA这样的静态语言，查询线上日志的方法是非常重要的。很多同学发现某个请求出问题了，就去看当次请求的日志，这种方式不一定准确。因为对于静态语言，它的案发第一现场可能已经不是当次请求了，很有可能是首次发生这个问题的时候，或者服务器刚刚启动的时候（静态语言的”缓存”特色）。当你发现上层的业务系统发生了mysql死锁的报错，就不要太纠结于上层业务系统的日志了。应该去看mysql的bin log，抓住这个案发第一现场，看看到底发生了什么。不知道怎么解决线上问题，99%是因为连案发第一现场都没找到，等你找到了，基本也有解决方法了。 人性：每个人都喜欢做省力的事情，喜欢的事情。但是人往往有偏见，根本没有想明白查线上问题的价值，就认为这是一个很low的事，是不可取的。对自己不了解的，未知的事物，应该敬畏和学习。 例子3-技术面试 问题：很多同学的技术经验已经很扎实了，也能写出很稳定的代码，但是作为技术面试官，为什么老是会看走眼呢？ 认知：对应聘者而言，能否独立解决问题是能通过面试的及格线，应聘者专业技术的掌握程度只决定offer薪资的高低。 解释：是不是觉得又来歪论拉？恩，继续解释一番。首先问你，你为什么要招人，我想信很多人都会这么说：当然是找你来帮我干活啊，我现在天天干到11点，累死了，急需人帮忙啊。恩，所以你很清楚，这个人是要能独立解决问题的，能帮你分担的，不是来了还要你天天在那里盯着的。但是我们看到很多同学的内心认知是混乱的，虽然他能看懂这句话，但是在面试的时候他会这么做：准备10个左右他擅长的技术细节问题，一个个问，应聘者只能答出5个，废柴，不送。答出7个，恩，可以进来。答出10个，还说了1个我不知道的，好牛逼，绝不能让他看出来我比他弱，否则进来后还怎么带他。但是这个和你之前痛恨的应试教育又有什么区别呢？这种招聘方式有很大的风险招进来的人是研究手机屏幕从几楼摔下去不会碎，而不是研究让屏幕显示更清晰的人。正确的方式应该是：让他讲一个之前投入度比较高的项目，描述下自己是怎么独立去解决问题的。对每一个点的描述，只要你觉得还不能体现他“独立解决问题”的能力，那就继续扒皮深问，直到他竭尽全力，被你”逼到墙角”。特别优秀的人被逼到墙角后，具备现场把墙砸掉的能力，这样的人是死也不能放过的，具体什么意思大家可以去体会思考。之前我们曾经面试过一个性能测试工程师，从技术细节看对性能测试的工具和方法是比较了解的。在项目描述中我们问了他一个问题：你之前通过性能压测发现的服务端问题，有去了解过发生的原因吗？他给的答复是：因为我们是外企，制度比较明确，开发也是另外一个部门，所以我没有去了解。不好意思，这个回答基本体现了没有独立解决问题的能力乃至意识。碰到一堵很小的墙，他都没有办法独立解决，好奇和学习的欲望也很弱。他在技术细节上的积累只是因为看了几本书，用了几次工具，这些都只是为了应付面试和不懂的领导，根本没有深入实践，他未来的瓶颈一定非常大。只要能够独立解决问题，就一定能通过面试，有些技术不了解，最多就是被砍点薪资而已。在这一点上，10年工作经验的同学还真未必比得上2-3年工作经验的同学，如果没有独立解决问题的能力，那只是多累积了一些所谓的专业经验，但还是无法解决问题。很多大公司喜欢校招优秀的毕业生，也是这个原因，虽然这些学生还没有实际工作过，但已经具备了很强的独立解决问题能力。我们曾经招过一名同济大学的测试实习生，有一次她独立组织了部门的团建活动，搞得井井有条，方方面面都考虑到了，这样的同学做好技术只是时间问题。:) 人性：应聘者的人性有哪些呢？懒：影响独立解决问题的意识。 要面子：比如刚刚举的例子，拿公司制度掩盖自己无法独立解决问题的现状。（并且他自己是意识不到的，因为他内心的认知是混乱的） 盲目自信又不自信：对自己做的熟的东西盲目自信，对没接触过的技术很不自信。 例子4-最严重的线上故障 问题：到底是什么原因，会导致严重的线上故障呢？是我们团队的技术水平不高，还是流程问题才造成了如此严重的故障呢？ 认知：个体的过失很难造成严重的线上故障。真正的原因是：集体性的认知出错。 解释：在现代微服务的架构下，各服务之间的解耦性已经做得非常好了，总体来说出现全面严重问题的概率已经降得非常多了。就像一个国家一样，不怕局部的腐败，怕的是整个链条的腐败。举个例子，如果一个系统上线前，需要在数据库里配置一个关键的参数，如果不配置会导致很多请求处理错误。但是开发同学发生了错误的认知，潜意识里认为配置不是写代码=配置没有写代码技术含量高=配置没有写代码重要，最后把它忘了。测试同学认为测试配置不是测试新写的代码=优先测试新写的代码，再测试配置=测试代码比测试配置更重要，最后把它也忘了。那这基本上是救不回来了，上线后一定会发生严重的问题，每个链条的检查机制都失灵了。坚决预防集体性的认知出错，就可以避免很多严重的问题。集体性的认知出错往往是从一些小现象开始的，比如我们的团队曾经发生过一次正常的项目延期，原因是周五到了，没有完成测试，为了避免仓促上线出问题，所以延期一天发布。其实到这里都是非常正常的，但是当测试同学在钉钉群里发出这个原因的时候，有一些同学发出了大拇指的表情。注意，这个时候大家是没有犯错的，但是认知已经出现了偏差，变成了“以后就算测不完，只要说项目风险，就可以延期”。群里很多同学都看着，一旦这个集体性的认知偏差形成，未来项目的延期就会越来越多。所以需要立刻出来说一句：因为风险项目暂时不上可以，但是延期的原因要总结反思。通过这样一句让大家心里不太舒服的话，尽快把集体性认知偏差扭转过来。马云说过”小事要大做”，就是这个道理，不大做，等发生大事的时候就来不及了。 人性：盲目自信：对自己做的领域有天然的偏见，哪个重要，哪个不重要。随大流：别人也这么做了，应该不会错，还省力，我也这么做。懒：默守所谓的安全方案，其实在那个场景下已经不安全了，但是内心认知出现偏差，懒得去破局改进。 例子5-如何看待代码逻辑复用 问题：对于代码逻辑的复用，大家的看法往往不一样，有些同学认为只要是有公共性的代码都该不断抽出通用函数复用。有些则认为对重要的通用逻辑才该复用，过度复用反而增加成本。 认知：能力该复用，业务不该复用。分久必合，合久必分。 解释：这里提出了两个认知，我们来分别解释下。能力该复用，业务不该复用，这个很好理解。能力是指对这个系统有价值的功能，会长期存在且扩展下去的。而业务是一个泛指，既可以表示单一的产品需求，也可以表示某个局部的功能。比如你的应用里接入了一个支付宝支付，对支付这个事情我们判断下来是一个基础核心能力，且将来很有可能也要接入微信支付，所以应该抽出公共的函数。再比如对于客户端的登录页面和注册页面，虽然渲染逻辑90%是一样的，但是不应该复用，因为它们是单一功能，不是能力，贸然复用反而带来了很大的风险。分久必合，合久必分，这个的理解就很有意思了。大家都知道，这句话的出处来自三国演义，说的是一个国家分裂久了就会合并，合并久了也会分裂，其实对代码逻辑的复用也是如此。大家在合并抽出公共函数时，会发现有10%-20%的逻辑不是那么顺眼，总感觉暂时放在里面是可以的，但将来可能会拆出来。那么在写公共函数时，就要特别注意这部分逻辑。它虽然暂时在函数里，但是需要做到和上下文相对隔离，甚至还可以加入明显的换行和TO DO，为下一次的拆做好准备。而在拆出一些独立逻辑的时候，也要思考这些逻辑可能和其它的哪些逻辑有机会是合起来的，那么尽量放在一个类里，一个包里，为后续的合做好准备。 人性：不要刻舟求剑，妄图用一套规则来应对外部复杂变化的世界，要因地制宜，实事求是，学会变通。 例子6-开源的意义 问题：为什么现在很多中国的互联网公司开始重视开源的宣传了？ 认知：开源直接决定了公司的成本收入，以及人才储备 解释：是不是要崩溃了，开源无偿写代码，然后免费给别人用，不是在消耗公司成本吗？别急，还记得马云说过的一句话吗，“免费的才是最贵的”。恩，这个道理同样适用于开源。今天中国很多的互联网公司已经非常明白了，甭管你的开源技术到底好不好用，宣传一定要大，一定要让大家参与进来。带来的好处太多了，因为用了你的开源消息队列，之后就会用你的云计算平台。因为程序员都很懒，开发环境和线上保持一套嘛，你后面一定能赚大钱。因为开源项目非常知名，让你公司的技术形象立刻高大起来（先不管这个项目到底创造了多少有价值的产品），每年校招的优质学生资源尽收囊中，其他公司要抢人，只能花更多的钱。而每年中国优秀的毕业生就那么多，早就供需失衡，谁抢到了大部分，那之后在技术上一定能保持绝对优势。最后万一公司财报不好看了，不好意思开始收授权费，就像google收android的费用一样。不作恶只是口号，开源带来了无比巨大的利益，不能赚钱，谁开源？！现在微软也懂了这个道理，成为了开源社区的标杆，但在早期的鲍尔默时代可是出现了认知偏差呢。 人性：开源者的人性：追求利益，喜欢声誉。 接受开源的人：渴望进步，赚便宜，崇拜权威。 关键点：如何提升认知内心简单 内心越简单的人，将来能到达的境界就越高。大家千万不要误解了，我说的不是思想浅薄，而是内心简单纯粹要像少年一样。一个很好的例子，郭靖，用世俗的眼光来看他天资不高，开始学什么都慢。但是他有一个很大的优点，就是想法简单，无私心，持之以恒。报家仇，报国仇，保护好他爱的人，不会去想是不是别人骗了他，他多做一点是不是亏了。20岁就达到五绝水平，最后终于融合“降龙十八掌”、“九阴真经”和“左右互搏”三大盖世武功为一体，武林尊为“天下第一侠士”。 内心越简单，就越不会花费额外的精力在一些无关紧要的事上面。随着时间的推移，你的认知水平就一定能提升得更快。不要去想今天你学的语言明天是否还流行，先利用当前语言训练好你的思维模式。不要去想我作为测试给开发指出太多问题后，开发会不会不爽，做为测试你的核心是保证产品质量。不要去想今天我帮组内的开发分担了额外的代码编写，我是不是亏了，这些付出一定会在将来某个时候兑现，因为你比他们有更多的代码实践。 相信跨界的力量 ipod+手机诞生了iphone，手机+钱包诞生了支付宝，c,python+java诞生了go，人类的创新其实都是来自于跨界的结合。很多时候大家去看一个技术大神，会认为他一定是看了很多专业的书，看了很多牛逼开源项目的代码，写了很多项目才达到现在的这个水平。然后又看到别人的兴趣爱好：音乐，滑雪，画画，牛逼，大神就是大神，做好技术的同时还能“兼顾”这些兴趣。 这个认知完全错了好吗，我告诉你，写代码看书固然很重要，但如果他没有这些兴趣，他在技术上可能根本达不到今天的程度。一个有画画功底的人，理解向量，理解数据的PCA分析就是快好吗。一个财务出身的人，写支付系统的代码就是不容易出错好吗。人类的大脑从来都是一个网状的，互相关联的知识图谱，根本不存在靠”单一事物”修炼成功的好吗。千万不要成为技术上的孔乙己，天天学各种API的写法，和学习茴香豆的茴字有几种写法没有任何区别。 在方案想不出来的时候，在代码水平感觉到瓶颈的时候，在看不懂一些专业书籍的时候，一定要跳出来，和自己的兴趣结合，和自己经历结合，和自己的生活结合，这样才能突破瓶颈，提升到更上一层的认知。 相信更高认知人的指引 科幻神作三体里，外星人看地球人就像纸片一样，在三体人的眼中，地球人是二维的，而不是三维的。回到现实中，高认知的人看低认知的人也是一样的，不是低认知的人不够努力，而是你的知识图谱里比高认知的人少了一些维度。所以不管你怎么努力，你会发现仍旧无法超过他，他还比你轻松，学霸给大家留下的阴影就是这么来的。 在实际工作中，你的leader，你的架构师只要不是水货，往往他们的认知就是比你高的。一旦你觉得这个人的本性是靠谱的，你就该无条件去相信他给你的建议和指引。因为他能看到在你那个维度上感受不到的东西，照他的话去实践几次，你才有机会到达他那个维度，才能升级认知。不过在现实情况中，我们往往看到很多leader和架构给下面的同学苦口婆心说了很多，但是他们不理解，反而更叛逆。这份痛苦我懂，你是拼了命想拉他到你那个维度，但是他还年轻着呢。:) 持之以恒地实践人就是一个如此奇妙，如此复杂的生物，不管你看多少书，看多少源码，写多少demo，你不真刀真枪地去实践，去写代码，这些知识无论如何都无法进入你大脑的知识图谱。它们永远只能是“狭义上的知识”，而不是“有价值的认知”。相信大家人生中都有过类似的经历了，越是辛苦的实践，越是坚持，你最后的收获一定越大。简单来说，认知不通过持之以恒的实践是不可能升级的。还有一点我必须要强调，实践应该尽量和公司的项目去结合，而不是依靠于自己写demo。这里面有一个很大的误区，自己私下写demo经常是没有“明确，高压的”目标的（人性总是偏懒的），这种实践往往很难提升认知。而公司的项目往往不同，会提出”支持多少用户访问”，“为什么你每次开发都不能更快一点”（核心挑战的是你架构的扩展能力），“为什么这个功能这么卡”（性能优化），这些“明确的，高压的”目标能督促你去拼命提升自己的认知（只是写demo是很难给自己设下这些障碍的，是反人性的）。当然从结果来看，又是公司的压榨剥削拉，让我们回忆一下前面说的，如果你觉得这个公司是靠谱的，那就让我们的“内心简单一点”，持之以恒地实践升级认知吧。:)最后总结一下，现在已经不是一个单纯比拼知识量的时代，而是比拼认知高低的时代。作为程序员我们并不特殊，和市场，财务，产品，运营的这些同学一样，核心看的是认知，并不存在谁比谁困难，谁比谁辛苦的这种浅层比较。而我们学习的那些语言，框架，工具，和我们大学时期学习的微积分，高等物理没有区别，都只是帮助我们不断训练提升认知的实践工具，而不是认知本身。让我们不要再局限于程序员狭义技术的范畴内，把提升自己的认知作为最重要的目标，我们要努力做到“既是程序员，也不是程序员”。 最后总结一下，现在已经不是一个单纯比拼知识量的时代，而是比拼认知高低的时代。作为程序员我们并不特殊，和市场，财务，产品，运营的这些同学一样，核心看的是认知，并不存在谁比谁困难，谁比谁辛苦的这种浅层比较。而我们学习的那些语言，框架，工具，和我们大学时期学习的微积分，高等物理没有区别，都只是帮助我们不断训练提升认知的实践工具，而不是认知本身。让我们不要再局限于程序员狭义技术的范畴内，把提升自己的认知作为最重要的目标，我们要努力做到“既是程序员，也不是程序员”。 作者：刘轶链接：https://juejin.im/post/5c3f23606fb9a049b50715f0来源：掘金]]></content>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于yii-gii实现的一个批量生成模型测试的拓展工具]]></title>
    <url>%2F2019%2F01%2F14%2F%E5%9F%BA%E4%BA%8Eyii-gii%E5%AE%9E%E7%8E%B0%E7%9A%84%E4%B8%80%E4%B8%AA%E6%89%B9%E9%87%8F%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8B%E6%B5%8B%E8%AF%95%E7%9A%84%E6%8B%93%E5%B1%95%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[场景 项目离不开业务，业务离不开需求，所以就离不开CURD。项目上线的时候，我们需要批量进行数据库迁移，这个时候我们需要确保migrate是万无一失的，能够百分百保证每个model的curd能够准确的执行，通常我们可以自行编写model的功能测试，确保curd的成功率，但是如果项目涉及很多model的话就很难受了，不可能一个一个去写测试，所以基于yii-gii这个拓展，自定义了一个批量生成模型测试的拓展。 实现 这里不太想详细去介绍如何实现，深入了解yii-gii的原理基本都是没有问题的，自定义生成器，然后按照自己的预期写好生成器的model即可，这里贴下我的实现成果： gayhub：https://github.com/BinZhiZhu/yii-curd-cest-gii]]></content>
      <tags>
        <tag>yii</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[msyql多表查询sum()重复累加问题]]></title>
    <url>%2F2019%2F01%2F08%2Fmsyql%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2sum-%E9%87%8D%E5%A4%8D%E7%B4%AF%E5%8A%A0%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[前言 今天产品那边反馈了一个bug：部分订单金额（筛选场景）统计的订单总额不对。我就觉得好奇了，咋会部分就不对呢？然后我就开始场景复现了，果真复现了，我们一起来看下这个问题。 场景复现1.搜索订单（一个订单多个商品），这样容易复现，订单号：SH20190107120514818483。2.该订单购买了两个商品，A商品100元，B商品0元，合计是100元。3.此时订单数：1 ;订单金额：200 定位问题表：订单表（A）：shop_order 订单商品表（B）：shop_order_goods mysql 代码：1SELECT COUNT(DISTINCT(o.id)) as count, ifnull(sum(o.price),0) as sumprice FROM ims_new_shop_order o left join ims_new_shop_order_refund r on r.id =o.refundid left join ims_new_shop_member m on m.openid=o.openid and m.uniacid = o.uniacid left join ims_new_shop_member_address a on o.addressid = a.id left join ims_new_shop_saler s on s.openid = o.verifyopenid and s.uniacid=o.uniacid left join ims_new_shop_member sm on sm.openid = s.openid and sm.uniacid=s.uniacid left join ims_new_shop_order_goods sog on sog.uniacid = o.uniacid and sog.orderid = o.id left join ims_new_shop_goods sg on sg.uniacid = o.uniacid and sg.id = sog.goodsid WHERE o.uniacid = 1 and o.deleted=0 and o.isparent=0 and o.istrade=0 AND locate(&apos;SH20190107120514818483&apos;,o.ordersn)&gt;0 AND o.create_from_wxapp = 0 问题：我们会发现A表左连接B表的时候是不排除一对多的，也就是A表一条订单对应B表多条记录，但实际上这个时候我们需要去sum的金额仅仅是A表的订单金额，关联B表有多少记录我们是不需要在乎的。这个时候相当于重复统计了A表的订单金额，其实是受到了B表的影响。 解决方案 我们应该应该怎么处理： 实际上我们只需要在A表连接B表的时候，B表单独子查询处理，因为我们需要##去重B表的重复记录##，所有需要对B表group by进行分组，这样的话就不会出现sum累计的问题了。 ##A left join (SELECT id,uniacid,orderid,goodsid FROM ims_new_shop_order_goods GROUP BY goodsid) ## AS sog on C## 更改后代码：1SELECT COUNT(DISTINCT(o.id)) as count, ifnull(sum(o.price),0) as sumprice FROM ims_new_shop_order o left join ims_new_shop_order_refund r on r.id =o.refundid left join ims_new_shop_member m on m.openid=o.openid and m.uniacid = o.uniacid left join ims_new_shop_member_address a on o.addressid = a.id left join ims_new_shop_saler s on s.openid = o.verifyopenid and s.uniacid=o.uniacid left join ims_new_shop_member sm on sm.openid = s.openid and sm.uniacid=s.uniacid left join (SELECT id,uniacid,orderid,goodsid FROM ims_new_shop_order_goods GROUP BY goodsid) AS sog on sog.uniacid = o.uniacid and sog.orderid = o.id left join ims_new_shop_goods sg on sg.uniacid = o.uniacid and sg.id = sog.goodsid WHERE o.uniacid = 1 and o.deleted=0 and o.isparent=0 and o.istrade=0 AND locate(&apos;SH20190107120514818483&apos;,o.ordersn)&gt;0 AND o.create_from_wxapp = 0]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高仿快递智能识别地址功能]]></title>
    <url>%2F2018%2F12%2F14%2F%E9%AB%98%E4%BB%BF%E5%BF%AB%E9%80%92%E6%99%BA%E8%83%BD%E8%AF%86%E5%88%AB%E5%9C%B0%E5%9D%80%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[前言 这周接到一个项目功能，大致就类似快递类寄件智能识别收货地址，只需要复制粘贴地址信息，点击完成就直接填写到了对应的地址信息的输入框。 我简单的举个例子吧： 小埋13000000000广东省广州市天河区体育西路xxx号 上面就会自动识别为： 收货人：小埋 电话：13000000000 省市区：广东省 广州市 天河区 地址：体育西路xxx号这样就认为是智能识别了，不需要一个一个去手动填写，只需要复制粘贴物流地址信息即可。说是这样说，但实际上内心是一万只曹尼玛 ^ ^ 前期准备 我开始是再Google搜索有没有相关的第三方SDK，一般都会这样去思考，只需要调第三方sdk接口即可，但是实际上会有一个问题：地址库！！！ 现公司内部使用的地址库是腾讯开发的Jquery Weui组件库中的cityPicker，也就是填写省市区的地址选择器，所以地址库不统一的话是一个硬伤。 gayHub 地址 [smart-parse]: https://github.com/BinZhiZhu/smart-parse]]></content>
  </entry>
  <entry>
    <title><![CDATA[mysql-Expression #1 of SELECT list is not in GROUP BY clause解决方案]]></title>
    <url>%2F2018%2F11%2F30%2Fmysql-Expression-1-of-SELECT-list-is-not-in-GROUP-BY-clause%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[##前言 最近部署自己项目到服务器后，运行时mysql报错，抛出异常的代码为： 1Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column &apos;support_desk.mod_users_groups.group_id&apos; which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by 谷歌翻译一下大概意思： SELECT列表的表达式＃1不在GROUP BY子句中，并且包含非聚合列’support_desk.mod_users_groups.group_id’，它在功能上不依赖于GROUP BY子句中的列; 这与sql_mode = only_full_group_by不兼容 解决方案 实锤是因为MySQL版本的原因，我去StackOverflow查了相关的解决方案，最终还是解决了这个问题。 cd /etc/my.cnf 或者etc/mysql/my.cnf 不清楚路径可以 whereis my.cnf 打印pwd路径 vim my.cnf 添加sql_mode 12[mysqld] sql_mode = STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION esc :wq 报错退出 重启一下mysql服务 sudo service mysql restart / 或者/etc/init.d/mysql restart等等都可以 除了上面这种方法也可以直接连接mysql 通过mysql-&gt;set …[sql_mode] 类似 这样问题就解决了，最后贴一下解决方案的地址 [stackoverflow]：https://stackoverflow.com/questions/34115174/error-related-to-only-full-group-by-when-executing-a-query-in-mysql]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[探讨Tencent/weui.js之picker组件库]]></title>
    <url>%2F2018%2F11%2F30%2F%E6%8E%A2%E8%AE%A8Tencent-weui-js%E4%B9%8Bpicker%E7%BB%84%E4%BB%B6%E5%BA%93%2F</url>
    <content type="text"><![CDATA[Functionspicker(items, options)picker 多列选择器。datePicker(options)datePicker 时间选择器，由picker拓展而来，提供年、月、日的选择。 picker(items, options)picker 多列选择器。 Kind: global function Param Type Default Description items array picker的数据，即用于生成picker的数据，picker的层级可以自己定义，但建议最多三层。数据格式参考example。 options Object 配置项 [options.depth] number picker深度(也就是picker有多少列) 取值为1-3。如果为空，则取items第一项的深度。 [options.id] string &quot;default&quot; 作为picker的唯一标识，作用是以id缓存当时的选择。（当你想每次传入的defaultValue都是不一样时，可以使用不同的id区分） [options.className] string 自定义类名 [options.container] string 指定容器 [options.defaultValue] array 默认选项的value数组 [options.onChange] function 在picker选中的值发生变化的时候回调 [options.onConfirm] function 在点击”确定”之后的回调。回调返回选中的结果(Array)，数组长度依赖于picker的层级。 [options.onClose] function picker关闭后的回调 Example12345678910111213141516171819202122232425262728293031// 单列pickerweui.picker([&#123; label: '飞机票', value: 0, disabled: true // 不可用&#125;,&#123; label: '火车票', value: 1&#125;,&#123; label: '汽车票', value: 3&#125;,&#123; label: '公车票', value: 4,&#125;], &#123; className: 'custom-classname', container: 'body', defaultValue: [3], onChange: function (result) &#123; console.log(result) &#125;, onConfirm: function (result) &#123; console.log(result) &#125;, id: 'singleLinePicker'&#125;); Example123456789101112131415161718192021222324252627282930313233// 多列pickerweui.picker([ &#123; label: '1', value: '1' &#125;, &#123; label: '2', value: '2' &#125;, &#123; label: '3', value: '3' &#125;], [ &#123; label: 'A', value: 'A' &#125;, &#123; label: 'B', value: 'B' &#125;, &#123; label: 'C', value: 'C' &#125;], &#123; defaultValue: ['3', 'A'], onChange: function (result) &#123; console.log(result); &#125;, onConfirm: function (result) &#123; console.log(result); &#125;, id: 'multiPickerBtn'&#125;); Example12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// 级联pickerweui.picker([&#123; label: '飞机票', value: 0, children: [ &#123; label: '经济舱', value: 1 &#125;, &#123; label: '商务舱', value: 2 &#125; ]&#125;,&#123; label: '火车票', value: 1, children: [ &#123; label: '卧铺', value: 1, disabled: true // 不可用 &#125;, &#123; label: '坐票', value: 2 &#125;, &#123; label: '站票', value: 3 &#125; ]&#125;,&#123; label: '汽车票', value: 3, children: [ &#123; label: '快班', value: 1 &#125;, &#123; label: '普通', value: 2 &#125; ]&#125;], &#123; className: 'custom-classname', container: 'body', defaultValue: [1, 3], onChange: function (result) &#123; console.log(result) &#125;, onConfirm: function (result) &#123; console.log(result) &#125;, id: 'doubleLinePicker'&#125;); datePicker(options)datePicker 时间选择器，由picker拓展而来，提供年、月、日的选择。 Kind: global function Param Type Default Description options 配置项 [options.id] string &quot;datePicker&quot; 作为picker的唯一标识 [options.start] number &#124; string &#124; Date 2000 起始年份，如果是 Number 类型，表示起始年份；如果是 String 类型，格式为 ‘YYYY-MM-DD’；如果是 Date 类型，就传一个 Date [options.end] number &#124; string &#124; Date 2030 结束年份，同上 [options.cron] string &quot; *&quot; cron 表达式，三位，分别是 dayOfMonth[1-31]，month[1-12] 和 dayOfWeek[0-6]（周日-周六） [options.className] string 自定义类名 [options.defaultValue] array 默认选项的value数组, 如 [1991, 6, 9] [options.onChange] function 在picker选中的值发生变化的时候回调 [options.onConfirm] function 在点击”确定”之后的回调。回调返回选中的结果(Array)，数组长度依赖于picker的层级。 Example12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// 示例1：weui.datePicker(&#123; start: 1990, end: 2000, defaultValue: [1991, 6, 9], onChange: function(result)&#123; console.log(result); &#125;, onConfirm: function(result)&#123; console.log(result); &#125;, id: 'datePicker'&#125;);// 示例2：weui.datePicker(&#123; start: new Date(), // 从今天开始 end: 2030, defaultValue: [2020, 6, 9], onChange: function(result)&#123; console.log(result); &#125;, onConfirm: function(result)&#123; console.log(result); &#125;, id: 'datePicker' &#125;); // 示例3：weui.datePicker(&#123; start: new Date(), // 从今天开始 end: 2030, cron: '* * 0,6', // 每逢周日、周六 onChange: function(result)&#123; console.log(result); &#125;, onConfirm: function(result)&#123; console.log(result); &#125;, id: 'datePicker' &#125;); // 示例4：weui.datePicker(&#123; start: new Date(), // 从今天开始 end: 2030, cron: '1-10 * *', // 每月1日-10日 onChange: function(result)&#123; console.log(result); &#125;, onConfirm: function(result)&#123; console.log(result); &#125;, id: 'datePicker' &#125;);]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>weui</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[探讨Tencent/weui.js]]></title>
    <url>%2F2018%2F11%2F30%2F%E6%8E%A2%E8%AE%A8Tencent-weui-js%2F</url>
    <content type="text"><![CDATA[##认识WeUI WeUI 的轻量级 js 封装。 注意：由于微信小程序不支持dom操作，所以weui.js并不适用于小程序。不过WeUI也为小程序开发了另外的版本，详情请看：https://github.com/Tencent/weui-wxss/ 手机预览：https://weui.io/weui.js/ ##安装 1234git clone https://github.com/Tencent/weui.js.gitcd weui.jsnpm installnpm start ##编译 1npm run build ##使用 global123456&lt;link rel=&quot;stylesheet&quot; href=&quot;https://res.wx.qq.com/open/libs/weui/1.1.3/weui.min.css&quot;&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;https://res.wx.qq.com/open/libs/weuijs/1.1.4/weui.min.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; weui.alert(&apos;alert&apos;);&lt;/script&gt; import as module1234import &apos;weui&apos;;import weui from &apos;weui.js&apos;;weui.alert(&apos;alert&apos;); ##文档 [文档]：https://github.com/Tencent/weui.js/blob/master/docs/README.md ##Github [github]：https://github.com/Tencent/weui.js]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>weui</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[fsockopen实现发起异步请求忽略返回值]]></title>
    <url>%2F2018%2F11%2F29%2Ffsockopen%E5%AE%9E%E7%8E%B0%E5%8F%91%E8%B5%B7%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82%E5%BF%BD%E7%95%A5%E8%BF%94%E5%9B%9E%E5%80%BC%2F</url>
    <content type="text"><![CDATA[##前言 前段时间有个需求，我大概描述一下：用户进入公众号或者小程序的所有操作类行为的日志需要后端上报到内部的客户雷达小程序，而且需要异步请求，不需要等待返回。简单来说就是当用户进入小程序点击某件商品或者加入购物车、下单等等操作，上报到雷达小程序，商户会时序看到哪个用户进来我的商店买了哪件商品，浏览了哪些商品，下了多少单等等，都可以随时看到。这个时候我们就可能要需要思考了，要如何做到发起异步请求并且忽略返回值，前端那边不需要等待后端的返回，我也查看过相关资料，最后参考了下面这种方法。 发起异步请求 忽略返回值（后端技术PHP） 自己封装一个方法吧 我直接上代码 1234567891011121314151617181920212223242526272829/** * 发起异步请求，忽略返回值 * @param $url 上报地址 例如http://www.binzhizhu.top * @param array $params 上报的参数 * @return bool */public static function asyncPost($url, $params = [])&#123; Yii::info(&quot;into asyncPost &quot;, __METHOD__); $args = parse_url($url); $host = $args[&apos;host&apos;]; //域名 $path = $args[&apos;path&apos;] . &apos;?&apos; . http_build_query($params);//上报的参数 $fp = fsockopen($host, 80, $error_code, $error_msg, 1);//使用fsockopen方法发起异步请求 if (!$fp) &#123; Yii::error($error_code . &apos; _ &apos; . $error_msg, __METHOD__); return false; &#125; else &#123; stream_set_blocking($fp, true);//开启了手册上说的非阻塞模式 stream_set_timeout($fp, 1);//设置超时 $header = &quot;GET $path HTTP/1.1\r\n&quot;; // GET/POST请求 http1.1协议 $header .= &quot;Host: $host\r\n&quot;; $header .= &quot;Connection: close\r\n\r\n&quot;;//长连接关闭 fwrite($fp, $header); fclose($fp); &#125;&#125;]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Http</tag>
        <tag>Php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Axios--基于 promise 的 HTTP 库]]></title>
    <url>%2F2018%2F11%2F28%2FAxios-%E5%9F%BA%E4%BA%8E-promise-%E7%9A%84-HTTP-%E5%BA%93%2F</url>
    <content type="text"><![CDATA[##认识Axios Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。 Features 从浏览器中创建 XMLHttpRequests 从 node.js 创建 http 请求 支持 Promise API 拦截请求和响应 转换请求数据和响应数据 取消请求 自动转换 JSON 数据 客户端支持防御 XSRF 安装使用 npm: 1$ npm install axios 使用 bower: 1$ bower install axios 使用cdn: 1&lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt; Example ###执行 Get 请求 123456789101112131415161718192021为给定 ID 的 user 创建请求axios.get(&apos;/user?ID=12345&apos;) .then(function (response) &#123; console.log(response); &#125;) .catch(function (error) &#123; console.log(error); &#125;); 可选地，上面的请求可以这样做axios.get(&apos;/user&apos;, &#123; params: &#123; ID: 12345 &#125; &#125;) .then(function (response) &#123; console.log(response); &#125;) .catch(function (error) &#123; console.log(error); &#125;); ###执行 POST 请求 axios.post(&apos;/user&apos;, { firstName: &apos;Fred&apos;, lastName: &apos;Flintstone&apos; }) .then(function (response) { console.log(response); }) .catch(function (error) { console.log(error); }); ###执行多个并发请求 function getUserAccount() { return axios.get(‘/user/12345’); } function getUserPermissions() { return axios.get(‘/user/12345/permissions’); } axios.all([getUserAccount(), getUserPermissions()]) .then(axios.spread(function (acct, perms) { 两个请求现在都执行完成 })); axios API 可以通过向 axios 传递相关配置来创建请求 axios(config) // 发送 POST 请求 axios({ method: ‘post’, url: ‘/user/12345’, data: { firstName: ‘Fred’, lastName: ‘Flintstone’ } }); axios(url[, config]) // 发送 GET 请求（默认的方法） axios(‘/user/12345’); 请求方法的别名 为方便起见，为所有支持的请求方法提供了别名 axios.request(config) axios.get(url[, config]) axios.delete(url[, config]) axios.head(url[, config]) axios.post(url[, data[, config]]) axios.put(url[, data[, config]]) axios.patch(url[, data[, config]]) 在使用别名方法时， url、method、data 这些属性都不必在配置中指定。 并发 处理并发请求的助手函数 axios.all(iterable) axios.spread(callback) 创建实例 以使用自定义配置新建一个 axios 实例 axios.create([config]) var instance = axios.create({ baseURL: ‘https://some-domain.com/api/&#39;, timeout: 1000, headers: {‘X-Custom-Header’: ‘foobar’} }); 实例方法 以下是可用的实例方法。指定的配置将与实例的配置合并 axios#request(config) axios#get(url[, config]) axios#delete(url[, config]) axios#head(url[, config]) axios#post(url[, data[, config]]) axios#put(url[, data[, config]]) axios#patch(url[, data[, config]]) 请求配置 这些是创建请求时可以用的配置选项。只有 url 是必需的。如果没有指定 method，请求将默认使用 get 方法。 { // url 是用于请求的服务器 URL url: ‘/user’, // `method` 是创建请求时使用的方法 method: &apos;get&apos;, // 默认是 get // `baseURL` 将自动加在 `url` 前面，除非 `url` 是一个绝对 URL。 // 它可以通过设置一个 `baseURL` 便于为 axios 实例的方法传递相对 URL baseURL: &apos;https://some-domain.com/api/&apos;, // `transformRequest` 允许在向服务器发送前，修改请求数据 // 只能用在 &apos;PUT&apos;, &apos;POST&apos; 和 &apos;PATCH&apos; 这几个请求方法 // 后面数组中的函数必须返回一个字符串，或 ArrayBuffer，或 Stream transformRequest: [function (data) { // 对 data 进行任意转换处理 return data; }], // `transformResponse` 在传递给 then/catch 前，允许修改响应数据 transformResponse: [function (data) { // 对 data 进行任意转换处理 return data; }], // `headers` 是即将被发送的自定义请求头 headers: {&apos;X-Requested-With&apos;: &apos;XMLHttpRequest&apos;}, // `params` 是即将与请求一起发送的 URL 参数 // 必须是一个无格式对象(plain object)或 URLSearchParams 对象 params: { ID: 12345 }, // `paramsSerializer` 是一个负责 `params` 序列化的函数 // (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/) paramsSerializer: function(params) { return Qs.stringify(params, {arrayFormat: &apos;brackets&apos;}) }, // `data` 是作为请求主体被发送的数据 // 只适用于这些请求方法 &apos;PUT&apos;, &apos;POST&apos;, 和 &apos;PATCH&apos; // 在没有设置 `transformRequest` 时，必须是以下类型之一： // - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams // - 浏览器专属：FormData, File, Blob // - Node 专属： Stream data: { firstName: &apos;Fred&apos; }, // `timeout` 指定请求超时的毫秒数(0 表示无超时时间) // 如果请求话费了超过 `timeout` 的时间，请求将被中断 timeout: 1000, // `withCredentials` 表示跨域请求时是否需要使用凭证 withCredentials: false, // 默认的 // `adapter` 允许自定义处理请求，以使测试更轻松 // 返回一个 promise 并应用一个有效的响应 (查阅 [response docs](#response-api)). adapter: function (config) { /* ... */ }, // `auth` 表示应该使用 HTTP 基础验证，并提供凭据 // 这将设置一个 `Authorization` 头，覆写掉现有的任意使用 `headers` 设置的自定义 `Authorization`头 auth: { username: &apos;janedoe&apos;, password: &apos;s00pers3cret&apos; }, // `responseType` 表示服务器响应的数据类型，可以是 &apos;arraybuffer&apos;, &apos;blob&apos;, &apos;document&apos;, &apos;json&apos;, &apos;text&apos;, &apos;stream&apos; responseType: &apos;json&apos;, // 默认的 // `xsrfCookieName` 是用作 xsrf token 的值的cookie的名称 xsrfCookieName: &apos;XSRF-TOKEN&apos;, // default // `xsrfHeaderName` 是承载 xsrf token 的值的 HTTP 头的名称 xsrfHeaderName: &apos;X-XSRF-TOKEN&apos;, // 默认的 // `onUploadProgress` 允许为上传处理进度事件 onUploadProgress: function (progressEvent) { // 对原生进度事件的处理 }, // `onDownloadProgress` 允许为下载处理进度事件 onDownloadProgress: function (progressEvent) { // 对原生进度事件的处理 }, // `maxContentLength` 定义允许的响应内容的最大尺寸 maxContentLength: 2000, // `validateStatus` 定义对于给定的HTTP 响应状态码是 resolve 或 reject promise 。如果 `validateStatus` 返回 `true` (或者设置为 `null` 或 `undefined`)，promise 将被 resolve; 否则，promise 将被 rejecte validateStatus: function (status) { return status &gt;= 200 &amp;&amp; status &lt; 300; // 默认的 }, // `maxRedirects` 定义在 node.js 中 follow 的最大重定向数目 // 如果设置为0，将不会 follow 任何重定向 maxRedirects: 5, // 默认的 // `httpAgent` 和 `httpsAgent` 分别在 node.js 中用于定义在执行 http 和 https 时使用的自定义代理。允许像这样配置选项： // `keepAlive` 默认没有启用 httpAgent: new http.Agent({ keepAlive: true }), httpsAgent: new https.Agent({ keepAlive: true }), // &apos;proxy&apos; 定义代理服务器的主机名称和端口 // `auth` 表示 HTTP 基础验证应当用于连接代理，并提供凭据 // 这将会设置一个 `Proxy-Authorization` 头，覆写掉已有的通过使用 `header` 设置的自定义 `Proxy-Authorization` 头。 proxy: { host: &apos;127.0.0.1&apos;, port: 9000, auth: : { username: &apos;mikeymike&apos;, password: &apos;rapunz3l&apos; } }, // `cancelToken` 指定用于取消请求的 cancel token // （查看后面的 Cancellation 这节了解更多） cancelToken: new CancelToken(function (cancel) { }) } 响应结构 某个请求的响应包含以下信息 { // data 由服务器提供的响应 data: {}, // `status` 来自服务器响应的 HTTP 状态码 status: 200, // `statusText` 来自服务器响应的 HTTP 状态信息 statusText: &apos;OK&apos;, // `headers` 服务器响应的头 headers: {}, // `config` 是为请求提供的配置信息 config: {} } 使用 then 时，你将接收下面这样的响应： axios.get(‘/user/12345’) .then(function(response) { console.log(response.data); console.log(response.status); console.log(response.statusText); console.log(response.headers); console.log(response.config); }); 在使用 catch 时，或传递 rejection callback 作为 then 的第二个参数时，响应可以通过 error 对象可被使用，正如在错误处理这一节所讲。 配置的默认值/defaults 你可以指定将被用在各个请求的配置默认值 全局的 axios 默认值 axios.defaults.baseURL = ‘https://api.example.com&#39;; axios.defaults.headers.common[‘Authorization’] = AUTH_TOKEN; axios.defaults.headers.post[‘Content-Type’] = ‘application/x-www-form-urlencoded’; 自定义实例默认值 // 创建实例时设置配置的默认值 var instance = axios.create({ baseURL: ‘https://api.example.com&#39; }); // 在实例已创建后修改默认值 instance.defaults.headers.common[‘Authorization’] = AUTH_TOKEN; 配置的优先顺序 配置会以一个优先顺序进行合并。这个顺序是：在 lib/defaults.js 找到的库的默认值，然后是实例的 defaults 属性，最后是请求的 config 参数。后者将优先于前者。这里是一个例子： // 使用由库提供的配置的默认值来创建实例 // 此时超时配置的默认值是 0 var instance = axios.create(); // 覆写库的超时默认值 // 现在，在超时前，所有请求都会等待 2.5 秒 instance.defaults.timeout = 2500; // 为已知需要花费很长时间的请求覆写超时设置 instance.get(‘/longRequest’, { timeout: 5000 }); 拦截器 在请求或响应被 then 或 catch 处理前拦截它们: // 添加请求拦截器 axios.interceptors.request.use(function (config) { // 在发送请求之前做些什么 return config; }, function (error) { // 对请求错误做些什么 return Promise.reject(error); }); // 添加响应拦截器 axios.interceptors.response.use(function (response) { // 对响应数据做点什么 return response; }, function (error) { // 对响应错误做点什么 return Promise.reject(error); }); 如果你想在稍后移除拦截器，可以这样： var myInterceptor = axios.interceptors.request.use(function () {/…/}); axios.interceptors.request.eject(myInterceptor); 可以为自定义 axios 实例添加拦截器 var instance = axios.create(); instance.interceptors.request.use(function () {/…/}); 错误处理 axios.get(‘/user/12345’) .catch(function (error) { if (error.response) { // 请求已发出，但服务器响应的状态码不在 2xx 范围内 console.log(error.response.data); console.log(error.response.status); console.log(error.response.headers); } else { // Something happened in setting up the request that triggered an Error console.log(‘Error’, error.message); } console.log(error.config); }); 可以使用 validateStatus 配置选项定义一个自定义 HTTP 状态码的错误范围。 axios.get(‘/user/12345’, { validateStatus: function (status) { return status &lt; 500; // 状态码在大于或等于500时才会 reject } }) 取消 使用 cancel token 取消请求 Axios 的 cancel token API 基于cancelable promises proposal，它还处于第一阶段。 可以使用 CancelToken.source 工厂方法创建 cancel token，像这样： var CancelToken = axios.CancelToken; var source = CancelToken.source(); axios.get(‘/user/12345’, { cancelToken: source.token }).catch(function(thrown) { if (axios.isCancel(thrown)) { console.log(‘Request canceled’, thrown.message); } else { // 处理错误 } }); // 取消请求（message 参数是可选的） source.cancel(‘Operation canceled by the user.’); 还可以通过传递一个 executor 函数到 CancelToken 的构造函数来创建 cancel token： var CancelToken = axios.CancelToken; var cancel; axios.get(‘/user/12345’, { cancelToken: new CancelToken(function executor(c) { // executor 函数接收一个 cancel 函数作为参数 cancel = c; }) }); // 取消请求 cancel(); tip : 可以使用同一个 cancel token 取消多个请求 Promises axios 依赖原生的 ES6 Promise 实现而被支持. 如果你的环境不支持 ES6 Promise，你可以使用 polyfill. TypeScript axios includes TypeScript definitions import axios from &apos;axios&apos;; axios.get(&apos;/user?ID=12345&apos;); 文章引用链接 [kancloud]: https://www.kancloud.cn/yunye/axios [GitHub Axios]: https://github.com/axios/axios [Axios API]: https://cn.vuejs.org/v2/cookbook/using-axios-to-consume-apis.html]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>axios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx 配置访问Access Denied]]></title>
    <url>%2F2018%2F11%2F21%2FNginx-%E9%85%8D%E7%BD%AE%E8%AE%BF%E9%97%AEAccess-Denied%2F</url>
    <content type="text"><![CDATA[前言 前段时间双11阿里云搞活动，于是便忍痛（花呗）入手了一台1核2G、40G系统盘、1M带宽的云服务ECS服务器。想着自己平时开发玩玩以及搭建自己的博客，所以就很爽快的买了，还顺便在阿里云买了一个.top的域名。也就是博客现在的这个域名，域名申请备案后，大概半个月左右收到备案通过的通知，于是我就开始解析域名到服务器，同时也把自己的项目在服务器搭建好。我是直接搭wget一键安装LNMP环境的，github clone下来，这个时候心想着配置一下虚拟域名应该就美滋滋了。 搭建过程的遇到的问题访问解析的域名连接重置 我刚开始以为是域名解析的问题，因为访问域名是一直显示正在连接，最后显示连接重置，也就是说无法连接到服务器，于是我问了一下其他朋友，在阿里云服务器添加了安全组，默认开启所有连接。其实开启http 80、https就可以了，其他看自己的需求，添加之后就不会显示连接重置了。 访问提示Access Denied 1access denied mlgj… 难受，解决了一个问题又出现了另外一个问题，访问项目提示access denied。我前前后后检查过Nginx的配置，真的觉得没有问题…。Nginx 提示successful，重启也正常。最让我觉得奇怪的是，访问域名提示access denied 的同时，可以看到网页的logo 已经访问到我项目的logo了，但是就完全没有任何反应，我自己去看Nginx日志也没相应的报错信息，我真的不知道该如何排查。 重新clone项目部署 我只好重新clone项目 重新认真部署一次 看看效果如何 未完待续。。。]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue.js结合ElementUI的（分页）进行前端分页]]></title>
    <url>%2F2018%2F11%2F17%2FVue-js%E7%BB%93%E5%90%88ElementUI%E7%9A%84%EF%BC%88%E5%88%86%E9%A1%B5%EF%BC%89%E8%BF%9B%E8%A1%8C%E5%89%8D%E7%AB%AF%E5%88%86%E9%A1%B5%2F</url>
    <content type="text"><![CDATA[前言 我们在开发的过程中总会遇到某些项目需要根据后台接口返回的数据进行前端分页显示，举个例子：电商项目中的订单列表页面。后台点击订单列表页的时候会去请求后端接口，前端根据后端返回的订单数据进行分页显示。虽然自己是一个后端人员，但今天处理一个后台改版的任务的时候，订单列表页用Vue写的，在对接写好的接口的时候，就遇到了这个分页的问题。那我们就一起来看下这个问题一般要如何解决吧。 思路 大致的想法是：后台返回所有订单数据，然后前端拿到返回的数据进行全部分页，这里注意的是：例如有100条记录，每页显示10条，这个时候实际分页效果是10页对吧，也就是说我们是后端一次性返回所有的订单数据，然后交给前端提前进行分页，每一页的数据我们在拿到后台返回的数据的时候前端就已经分好页了。 优点 分页切换的效果用户体验会更加顺畅； 当删除一条数据的时候过滤器会重新计算当前页面的显示数据 缺点 当页面数据量大的时候会浪费很多流量，因为有点类似于预加载的效果，一次把所有数据返回，数据多的时候RT时间会比较长 代码片段过滤器 我们应该先创建一个过滤器来过滤列表数据，这里有三个参数tabledata（列表数据），pageNum（当前第几页），pagesize（每页条数） 1234567filters:&#123; pagination(tabledata,pageNum,pagesize)&#123; let offset = (pageNum - 1) * pagesize;//当前页第一条的索引 let data=(offset + pagesize &gt;= tabledata.length) ? array.slice(offset, tabledata.length) : array.slice(offset, offset + pagesize); return data &#125; &#125; 完整代码 1234567891011121314151617&lt;template&gt; &lt;el-table :data=&quot;tableData | pagination(pageNum,pagesize)&quot;&gt; &lt;el-table-column label=&quot;&quot;&gt; &lt;template slot-scope=&quot;scope&quot;&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;/el-table&gt; &lt;el-pagination @size-change=&quot;handleSizeChange&quot; @current-change=&quot;handleCurrentChange&quot; :current-page=&quot;pageNo&quot; :page-size=&quot;pageSize&quot; layout=&quot; prev, pager, next, sizes, jumper&quot; :total=&quot;tableData.length&quot;&gt; &lt;/el-pagination&gt;&lt;/template&gt; 上面是elementui 的pagination 分页组件代码片段，不理解的直接去看文档即可 12345678910111213141516171819202122232425262728293031&lt;script&gt; export default&#123; data()&#123; return &#123; tableData: [&#123; id:&apos;&apos;, name:&apos;&apos;, &#125;], pagenum: 1, pagesize:10 &#125; &#125;, methods:&#123; handleSizeChange(val) &#123; console.log(`每页 $&#123;val&#125; 条`); this.pagesize=val; &#125;, handleCurrentChange(val) &#123; console.log(`当前页: $&#123;val&#125;`); this.pageNum = val; &#125; &#125;, filters:&#123; pagination(tabledata,pageNum,pagesize)&#123; let offset = (pageNum - 1) * pagesize;//当前页第一条的索引 let data=(offset + pagesize &gt;= tabledata.length) ? array.slice(offset, tabledata.length) : array.slice(offset, offset + pagesize); return data &#125; &#125; &#125;&lt;/script&gt; 总结：这种做法就比较舒服，用户体验也很好，切换分页的时候会很流畅。但还有另外的做法就是通过单页数据返回，每一次切换分页的时候去请求当前这个页面的数据，但是这种做法需要自己写上一页、下一页的方法，用户点击的时候去请求当前页面的数据去渲染，并不是一次性返回所有数据，这也是这种方法的优势，总的来说还得看具体的业务场景。 最后当然要贴一波效果图啊]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决Hexo首页阅读次数样式诡异的问题]]></title>
    <url>%2F2018%2F11%2F16%2F%E8%A7%A3%E5%86%B3Hexo%E9%A6%96%E9%A1%B5%E9%98%85%E8%AF%BB%E6%AC%A1%E6%95%B0%E6%A0%B7%E5%BC%8F%E8%AF%A1%E5%BC%82%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[前言 今晚在完善阅读统计的功能是时候发现一个很诡异的问题，我们一起来探讨一下。上一篇文章大概有阐述阅读统计功能的搭建，所有这里我就不多说了。 利用leancloud接完统计功能后，当前这个hexo版本我会发现首页的阅读数量的样式有点诡异，大致如下： 两种情况： 1：阅读次数::9:9 :2：阅读次数::99 实际上这个时候我们的阅读量只有9而已，正常来说应该这样显示： 阅读次数：9 于是我忍不住摁住F12一探究竟,大致可以知道阅读次数那一块的元素是js直接赋值的，所以我就去找了一下阅读统计的部分的相关js，我比较粗暴，直接定位全局搜索一波 leancloud_visitors 相关的文件 这是我们可以找到一个路径为 themes\next\layout_third-party\analytics\lean-analytics.swig 的文件，打开发现就是这部分js处理leancloud的阅读数量统计。 贴一波阅读次数统计的代码(LeanCloud提供支持) 看到function showTime 我相信你已经很明白了123456789101112131415161718192021222324252627282930313233&#123;% if theme.leancloud_visitors.enable %&#125; &#123;# custom analytics part create by xiamo #&#125; &lt;script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"&gt;&lt;/script&gt; &lt;script&gt;AV.initialize("&#123;&#123;theme.leancloud_visitors.app_id&#125;&#125;", "&#123;&#123;theme.leancloud_visitors.app_key&#125;&#125;");&lt;/script&gt; &lt;script&gt; function showTime(Counter) &#123; console.warn('~欢迎光临我的博客 Email:binzhizhu@gmail.com ') var query = new AV.Query(Counter); $(".leancloud_visitors").each(function() &#123; var url = $(this).attr("id").trim(); query.equalTo("url", url); query.find(&#123; success: function(results) &#123; console.warn('--这里是阅读统计代码-- by --leancloud--') if (results.length == 0) &#123; var content = $(document.getElementById(url)).text() + ': 0'; $(document.getElementById(url)).text(content); return; &#125; for (var i = 0; i &lt; results.length; i++) &#123; var object = results[i]; var content = $(document.getElementById(url)).text() + object.attributes.time; $(document.getElementById(url)).text(content); &#125; &#125;, error: function(object, error) &#123; console.log("Error: " + error.code + " " + error.message); &#125; &#125;); &#125;); &#125; 上述代码中的 for循环，看起来是没任何问题。但我hexo g -d 到GitHubPage 的时候，我再for循环里面console.log(‘obj’,object),打印了一下当前文章的所有属性，发现同一篇文章会打印两次，所有才会出现上面所说的 阅读次数::99的情况。相当于第一次循环time是9，循环了两次拼接了起来于是变成阅读次数::99 所有我 直接在for循环的最后加了一句 1return; 真.阅读统计代码段 这么做实际上很简单，类似于做一层兼容了，确保不会重复循环，修复了之后发现真的没有问题了，阅读次数显示正常了，美滋滋，这也是一种收获。顺便也贴一下其他阅读统计事件的代码片段吧： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253 function addCount(Counter) &#123; var Counter = AV.Object.extend(&quot;Counter&quot;); url = $(&quot;.leancloud_visitors&quot;).attr(&apos;id&apos;).trim(); title = $(&quot;.leancloud_visitors&quot;).attr(&apos;data-flag-title&apos;).trim(); var query = new AV.Query(Counter); query.equalTo(&quot;url&quot;, url); query.find(&#123; success: function(results) &#123; if (results.length &gt; 0) &#123; var counter = results[0]; counter.fetchWhenSave(true); counter.increment(&quot;time&quot;); counter.save(null, &#123; success: function(counter) &#123; var content = $(document.getElementById(url)).text() + &apos;: &apos; + counter.get(&apos;time&apos;); $(document.getElementById(url)).text(content); &#125;, error: function(counter, error) &#123; console.log(&apos;Failed to save Visitor num, with error message: &apos; + error.message); &#125; &#125;); &#125; else &#123; var newcounter = new Counter(); newcounter.set(&quot;title&quot;, title); newcounter.set(&quot;url&quot;, url); newcounter.set(&quot;time&quot;, 1); newcounter.save(null, &#123; success: function(newcounter) &#123; console.log(&quot;newcounter.get(&apos;time&apos;)=&quot;+newcounter.get(&apos;time&apos;)); var content = $(document.getElementById(url)).text() + &apos;: &apos; + newcounter.get(&apos;time&apos;); $(document.getElementById(url)).text(content); &#125;, error: function(newcounter, error) &#123; console.log(&apos;Failed to create&apos;); &#125; &#125;); &#125; &#125;, error: function(error) &#123; console.log(&apos;Error:&apos; + error.code + &quot; &quot; + error.message); &#125; &#125;); &#125; $(function() &#123; var Counter = AV.Object.extend(&quot;Counter&quot;); if ($(&apos;.leancloud_visitors&apos;).length == 1) &#123; addCount(Counter); &#125; else if ($(&apos;.post-title-link&apos;).length &gt; 1) &#123; showTime(Counter); &#125; &#125;); &lt;/script&gt;&#123;% endif %&#125; 这篇博客写得我有点疲惫了，已经深夜十分了，准备入睡啦，明天还要起来搬砖呢，晚安各位，希望能够帮助到大家吧，我也是刚学习Hexo自己搭建博客。 但有趣的一点是我们可以在这些开源的框架或者资源里面肆意的玩弄代码，hexo其实就是提供给大家开源开发的，看着文档接服务就好了，一大推的第三方服务已经Api。 最后发一个今天的自拍吧 哈哈哈！！！]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为NexT主题添加文章阅读量统计功能]]></title>
    <url>%2F2018%2F11%2F15%2F%E4%B8%BANexT%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E9%87%8F%E7%BB%9F%E8%AE%A1%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[前言最近刚入门Hexo+GithubPage搭建个人博客，基础的搭建完毕之后，总觉得缺少些技术性（代表）的功能，于是想到要不要在自己的博客搭建阅读统计的功能？但这个时候不太明白如何去实现，网上看了其他博主的一些建议之后，也打算使用learncloud这家服务商的资源解决我们的问题，所以我们得先去learncloud官网注册账号。]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[尝试使用Hexo+Github搭建个人博客]]></title>
    <url>%2F2018%2F11%2F14%2F%E5%B0%9D%E8%AF%95%E4%BD%BF%E7%94%A8Hexo-Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[##初探Hexo Hexo是一款基于Node.js的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在GitHub和Heroku上，是搭建博客的首选框架。这里我们选用的是GitHub，你没看错，全球最大的同性恋交友网站（逃……）。Hexo同时也是GitHub上的开源项目，参见：hexojs/hexo 如果想要更加全面的了解Hexo，可以到其官网 Hexo 了解更多的细节，因为Hexo的创建者是台湾人，对中文的支持很友好，可以选择中文进行查看。这里，默认各位猿/媛儿都知道GitHub就不再赘述。 ##搭建步骤 1.获得个人网站域名2.GitHub创建个人仓库3.安装Git4.安装Node.js5.安装Hexo6.推送网站7.绑定域名8.更换主题9.初识MarkDown语法10.发布文章11.寻找图床12.个性化设置 ##关于博主 本人博客地址：https://binzhizhu.github.io交流：binzhizhu@gmail.com网站：www.binzhizhu.top]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[北岛-《回答》]]></title>
    <url>%2F2018%2F11%2F14%2F%E5%8C%97%E5%B2%9B-%E3%80%8A%E5%9B%9E%E7%AD%94%E3%80%8B%2F</url>
    <content type="text"><![CDATA[回答 卑鄙是卑鄙者的通行证，高尚是高尚者的墓志铭，看吧，在那镀金的天空中，飘满了死者弯曲的倒影。冰川纪过去了，为什么到处都是冰凌？好望角发现了，为什么死海里千帆相竞？我来到这个世界上，只带着纸、绳索和身影，为了在审判之前，宣读那些被判决的声音。告诉你吧，世界我–不–相–信！纵使你脚下有一千名挑战者，那就把我算作第一千零一名。我不相信天是蓝的，我不相信雷的回声，我不相信梦是假的，我不相信死无报应。如果海洋注定要决堤，就让所有的苦水都注入我心中，如果陆地注定要上升，就让人类重新选择生存的峰顶。新的转机和闪闪星斗，正在缀满没有遮拦的天空。那是五千年的象形文字，那是未来人们凝视的眼睛。]]></content>
      <categories>
        <category>精神食物</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
</search>
