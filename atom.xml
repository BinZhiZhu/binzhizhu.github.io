<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>BinZhiZhu&#39;s Blog</title>
  
  <subtitle>Hello,World.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://binzhizhu.github.io/"/>
  <updated>2018-11-28T16:10:54.385Z</updated>
  <id>http://binzhizhu.github.io/</id>
  
  <author>
    <name>BinZhi Zhu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Axios--基于 promise 的 HTTP 库</title>
    <link href="http://binzhizhu.github.io/2018/11/28/Axios-%E5%9F%BA%E4%BA%8E-promise-%E7%9A%84-HTTP-%E5%BA%93/"/>
    <id>http://binzhizhu.github.io/2018/11/28/Axios-基于-promise-的-HTTP-库/</id>
    <published>2018-11-28T15:46:05.000Z</published>
    <updated>2018-11-28T16:10:54.385Z</updated>
    
    <content type="html"><![CDATA[<p>##认识Axios<br>  Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。</p><h2 id="Features"><a href="#Features" class="headerlink" title="Features"></a>Features</h2><ul><li>从浏览器中创建 XMLHttpRequests</li><li>从 node.js 创建 http 请求</li><li>支持 Promise API</li><li>拦截请求和响应</li><li>转换请求数据和响应数据</li><li>取消请求</li><li>自动转换 JSON 数据</li><li><p>客户端支持防御 XSRF</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>使用 npm:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install axios</span><br></pre></td></tr></table></figure><p>使用 bower:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ bower install axios</span><br></pre></td></tr></table></figure><p>使用cdn:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><p>  执行 <em>Get</em> 请求<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">为给定 ID 的 user 创建请求</span><br><span class="line">axios.get(&apos;/user?ID=12345&apos;)</span><br><span class="line">  .then(function (response) &#123;</span><br><span class="line">    console.log(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(function (error) &#123;</span><br><span class="line">    console.log(error);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"> 可选地，上面的请求可以这样做</span><br><span class="line">axios.get(&apos;/user&apos;, &#123;</span><br><span class="line">    params: &#123;</span><br><span class="line">      ID: 12345</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(function (response) &#123;</span><br><span class="line">    console.log(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(function (error) &#123;</span><br><span class="line">    console.log(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure></p><p>   执行 <em>POST</em> 请求</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> axios.post(&apos;/user&apos;, &#123;</span><br><span class="line">     firstName: &apos;Fred&apos;,</span><br><span class="line">     lastName: &apos;Flintstone&apos;</span><br><span class="line">   &#125;)</span><br><span class="line">   .then(function (response) &#123;</span><br><span class="line">     console.log(response);</span><br><span class="line">   &#125;)</span><br><span class="line">   .catch(function (error) &#123;</span><br><span class="line">     console.log(error);</span><br><span class="line">   &#125;);</span><br><span class="line"> ```      </span><br><span class="line">执行多个并发请求</span><br></pre></td></tr></table></figure><p>  function getUserAccount() {<br>    return axios.get(‘/user/12345’);<br>  }</p><p>  function getUserPermissions() {<br>    return axios.get(‘/user/12345/permissions’);<br>  }</p><p>  axios.all([getUserAccount(), getUserPermissions()])<br>    .then(axios.spread(function (acct, perms) {<br>      两个请求现在都执行完成<br>    }));<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> &lt;!-- more --&gt;</span><br><span class="line">## axios API</span><br><span class="line"></span><br><span class="line">可以通过向 *axios* 传递相关配置来创建请求</span><br><span class="line">*axios(config)*</span><br></pre></td></tr></table></figure></p><p>  // 发送 POST 请求<br>  axios({<br>    method: ‘post’,<br>    url: ‘/user/12345’,<br>    data: {<br>      firstName: ‘Fred’,<br>      lastName: ‘Flintstone’<br>    }<br>  });<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">axios(url[, config])</span><br></pre></td></tr></table></figure></p><p>  // 发送 GET 请求（默认的方法）<br>  axios(‘/user/12345’);<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  ## 请求方法的别名</span><br><span class="line">  </span><br><span class="line">  为方便起见，为所有支持的请求方法提供了别名</span><br><span class="line">  </span><br><span class="line">  axios.request(config)</span><br><span class="line">  axios.get(url[, config])</span><br><span class="line">  axios.delete(url[, config])</span><br><span class="line">  axios.head(url[, config])</span><br><span class="line">  axios.post(url[, data[, config]])</span><br><span class="line">  axios.put(url[, data[, config]])</span><br><span class="line">  axios.patch(url[, data[, config]])</span><br><span class="line">  </span><br><span class="line">  在使用别名方法时， url、method、data 这些属性都不必在配置中指定。</span><br><span class="line">  </span><br><span class="line">## 并发</span><br><span class="line">  处理并发请求的助手函数</span><br></pre></td></tr></table></figure></p><p>  axios.all(iterable)<br>  axios.spread(callback)<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">## 创建实例</span><br><span class="line">  以使用自定义配置新建一个 axios 实例</span><br><span class="line">  axios.create([config])</span><br></pre></td></tr></table></figure></p><p>  var instance = axios.create({<br>    baseURL: ‘<a href="https://some-domain.com/api/&#39;" target="_blank" rel="noopener">https://some-domain.com/api/&#39;</a>,<br>    timeout: 1000,<br>    headers: {‘X-Custom-Header’: ‘foobar’}<br>  });<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">### 实例方法</span><br><span class="line">以下是可用的实例方法。指定的配置将与实例的配置合并</span><br><span class="line">axios#request(config)</span><br><span class="line">axios#get(url[, config])</span><br><span class="line">axios#delete(url[, config])</span><br><span class="line">axios#head(url[, config])</span><br><span class="line">axios#post(url[, data[, config]])</span><br><span class="line">axios#put(url[, data[, config]])</span><br><span class="line">axios#patch(url[, data[, config]])</span><br><span class="line">## 请求配置</span><br><span class="line">这些是创建请求时可以用的配置选项。只有 *url* 是必需的。如果没有指定 *method*，请求将默认使用 *get* 方法。</span><br></pre></td></tr></table></figure></p><p>  {<br>    // <code>url</code> 是用于请求的服务器 URL<br>    url: ‘/user’,</p><pre><code>// `method` 是创建请求时使用的方法method: &apos;get&apos;, // 默认是 get// `baseURL` 将自动加在 `url` 前面，除非 `url` 是一个绝对 URL。// 它可以通过设置一个 `baseURL` 便于为 axios 实例的方法传递相对 URLbaseURL: &apos;https://some-domain.com/api/&apos;,// `transformRequest` 允许在向服务器发送前，修改请求数据// 只能用在 &apos;PUT&apos;, &apos;POST&apos; 和 &apos;PATCH&apos; 这几个请求方法// 后面数组中的函数必须返回一个字符串，或 ArrayBuffer，或 StreamtransformRequest: [function (data) {  // 对 data 进行任意转换处理  return data;}],// `transformResponse` 在传递给 then/catch 前，允许修改响应数据transformResponse: [function (data) {  // 对 data 进行任意转换处理  return data;}],// `headers` 是即将被发送的自定义请求头headers: {&apos;X-Requested-With&apos;: &apos;XMLHttpRequest&apos;},// `params` 是即将与请求一起发送的 URL 参数// 必须是一个无格式对象(plain object)或 URLSearchParams 对象params: {  ID: 12345},// `paramsSerializer` 是一个负责 `params` 序列化的函数// (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/)paramsSerializer: function(params) {  return Qs.stringify(params, {arrayFormat: &apos;brackets&apos;})},// `data` 是作为请求主体被发送的数据// 只适用于这些请求方法 &apos;PUT&apos;, &apos;POST&apos;, 和 &apos;PATCH&apos;// 在没有设置 `transformRequest` 时，必须是以下类型之一：// - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams// - 浏览器专属：FormData, File, Blob// - Node 专属： Streamdata: {  firstName: &apos;Fred&apos;},// `timeout` 指定请求超时的毫秒数(0 表示无超时时间)// 如果请求话费了超过 `timeout` 的时间，请求将被中断timeout: 1000,// `withCredentials` 表示跨域请求时是否需要使用凭证withCredentials: false, // 默认的// `adapter` 允许自定义处理请求，以使测试更轻松// 返回一个 promise 并应用一个有效的响应 (查阅 [response docs](#response-api)).adapter: function (config) {  /* ... */},// `auth` 表示应该使用 HTTP 基础验证，并提供凭据// 这将设置一个 `Authorization` 头，覆写掉现有的任意使用 `headers` 设置的自定义 `Authorization`头auth: {  username: &apos;janedoe&apos;,  password: &apos;s00pers3cret&apos;},// `responseType` 表示服务器响应的数据类型，可以是 &apos;arraybuffer&apos;, &apos;blob&apos;, &apos;document&apos;, &apos;json&apos;, &apos;text&apos;, &apos;stream&apos;responseType: &apos;json&apos;, // 默认的// `xsrfCookieName` 是用作 xsrf token 的值的cookie的名称xsrfCookieName: &apos;XSRF-TOKEN&apos;, // default// `xsrfHeaderName` 是承载 xsrf token 的值的 HTTP 头的名称xsrfHeaderName: &apos;X-XSRF-TOKEN&apos;, // 默认的// `onUploadProgress` 允许为上传处理进度事件onUploadProgress: function (progressEvent) {  // 对原生进度事件的处理},// `onDownloadProgress` 允许为下载处理进度事件onDownloadProgress: function (progressEvent) {  // 对原生进度事件的处理},// `maxContentLength` 定义允许的响应内容的最大尺寸maxContentLength: 2000,// `validateStatus` 定义对于给定的HTTP 响应状态码是 resolve 或 reject  promise 。如果 `validateStatus` 返回 `true` (或者设置为 `null` 或 `undefined`)，promise 将被 resolve; 否则，promise 将被 rejectevalidateStatus: function (status) {  return status &gt;= 200 &amp;&amp; status &lt; 300; // 默认的},// `maxRedirects` 定义在 node.js 中 follow 的最大重定向数目// 如果设置为0，将不会 follow 任何重定向maxRedirects: 5, // 默认的// `httpAgent` 和 `httpsAgent` 分别在 node.js 中用于定义在执行 http 和 https 时使用的自定义代理。允许像这样配置选项：// `keepAlive` 默认没有启用httpAgent: new http.Agent({ keepAlive: true }),httpsAgent: new https.Agent({ keepAlive: true }),// &apos;proxy&apos; 定义代理服务器的主机名称和端口// `auth` 表示 HTTP 基础验证应当用于连接代理，并提供凭据// 这将会设置一个 `Proxy-Authorization` 头，覆写掉已有的通过使用 `header` 设置的自定义 `Proxy-Authorization` 头。proxy: {  host: &apos;127.0.0.1&apos;,  port: 9000,  auth: : {    username: &apos;mikeymike&apos;,    password: &apos;rapunz3l&apos;  }},// `cancelToken` 指定用于取消请求的 cancel token// （查看后面的 Cancellation 这节了解更多）cancelToken: new CancelToken(function (cancel) {})</code></pre><p>  }<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">## 响应结构</span><br><span class="line">某个请求的响应包含以下信息</span><br></pre></td></tr></table></figure></p><p>  {<br>    // <code>data</code> 由服务器提供的响应<br>    data: {},</p><pre><code>// `status` 来自服务器响应的 HTTP 状态码status: 200,// `statusText` 来自服务器响应的 HTTP 状态信息statusText: &apos;OK&apos;,// `headers` 服务器响应的头headers: {},// `config` 是为请求提供的配置信息config: {}</code></pre><p>  }<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用 *then* 时，你将接收下面这样的响应：</span><br></pre></td></tr></table></figure></p><p>  axios.get(‘/user/12345’)<br>    .then(function(response) {<br>      console.log(response.data);<br>      console.log(response.status);<br>      console.log(response.statusText);<br>      console.log(response.headers);<br>      console.log(response.config);<br>    });<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在使用 catch 时，或传递 rejection callback 作为 then 的第二个参数时，响应可以通过 error 对象可被使用，正如在错误处理这一节所讲。</span><br><span class="line"></span><br><span class="line">## 配置的默认值/defaults</span><br><span class="line">你可以指定将被用在各个请求的配置默认值</span><br><span class="line">### 全局的 axios 默认值</span><br></pre></td></tr></table></figure></p><p>  axios.defaults.baseURL = ‘<a href="https://api.example.com&#39;" target="_blank" rel="noopener">https://api.example.com&#39;</a>;<br>  axios.defaults.headers.common[‘Authorization’] = AUTH_TOKEN;<br>  axios.defaults.headers.post[‘Content-Type’] = ‘application/x-www-form-urlencoded’;<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">### 自定义实例默认值</span><br></pre></td></tr></table></figure></p><p>  // 创建实例时设置配置的默认值<br>  var instance = axios.create({<br>    baseURL: ‘<a href="https://api.example.com&#39;" target="_blank" rel="noopener">https://api.example.com&#39;</a><br>  });</p><p>  // 在实例已创建后修改默认值<br>  instance.defaults.headers.common[‘Authorization’] = AUTH_TOKEN;<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">### 配置的优先顺序</span><br><span class="line">配置会以一个优先顺序进行合并。这个顺序是：在 *lib/defaults.js* 找到的库的默认值，然后是实例的 *defaults* 属性，最后是请求的 *config* 参数。后者将优先于前者。这里是一个例子：</span><br></pre></td></tr></table></figure></p><p>  // 使用由库提供的配置的默认值来创建实例<br>  // 此时超时配置的默认值是 <code>0</code><br>  var instance = axios.create();</p><p>  // 覆写库的超时默认值<br>  // 现在，在超时前，所有请求都会等待 2.5 秒<br>  instance.defaults.timeout = 2500;</p><p>  // 为已知需要花费很长时间的请求覆写超时设置<br>  instance.get(‘/longRequest’, {<br>    timeout: 5000<br>  });<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 拦截器</span><br><span class="line">在请求或响应被 *then* 或 *catch* 处理前拦截它们:</span><br></pre></td></tr></table></figure></p><p>  // 添加请求拦截器<br>  axios.interceptors.request.use(function (config) {<br>      // 在发送请求之前做些什么<br>      return config;<br>    }, function (error) {<br>      // 对请求错误做些什么<br>      return Promise.reject(error);<br>    });</p><p>  // 添加响应拦截器<br>  axios.interceptors.response.use(function (response) {<br>      // 对响应数据做点什么<br>      return response;<br>    }, function (error) {<br>      // 对响应错误做点什么<br>      return Promise.reject(error);<br>    });<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果你想在稍后移除拦截器，可以这样：</span><br></pre></td></tr></table></figure></p><p>  var myInterceptor = axios.interceptors.request.use(function () {/<em>…</em>/});<br>  axios.interceptors.request.eject(myInterceptor);<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可以为自定义 axios 实例添加拦截器</span><br></pre></td></tr></table></figure></p><p>  var instance = axios.create();<br>  instance.interceptors.request.use(function () {/<em>…</em>/});<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 错误处理</span><br></pre></td></tr></table></figure></p><p>  axios.get(‘/user/12345’)<br>    .catch(function (error) {<br>      if (error.response) {<br>        // 请求已发出，但服务器响应的状态码不在 2xx 范围内<br>        console.log(error.response.data);<br>        console.log(error.response.status);<br>        console.log(error.response.headers);<br>      } else {<br>        // Something happened in setting up the request that triggered an Error<br>        console.log(‘Error’, error.message);<br>      }<br>      console.log(error.config);<br>    });</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可以使用 *validateStatus* 配置选项定义一个自定义 HTTP 状态码的错误范围。</span><br></pre></td></tr></table></figure><p>  axios.get(‘/user/12345’, {<br>    validateStatus: function (status) {<br>      return status &lt; 500; // 状态码在大于或等于500时才会 reject<br>    }<br>  })<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">## 取消</span><br><span class="line">使用 *cancel token* 取消请求</span><br></pre></td></tr></table></figure></p><p>  Axios 的 cancel token API 基于cancelable promises proposal，它还处于第一阶段。<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可以使用 *CancelToken.source* 工厂方法创建 *cancel token*，像这样：</span><br></pre></td></tr></table></figure></p><p>  var CancelToken = axios.CancelToken;<br>  var source = CancelToken.source();</p><p>  axios.get(‘/user/12345’, {<br>    cancelToken: source.token<br>  }).catch(function(thrown) {<br>    if (axios.isCancel(thrown)) {<br>      console.log(‘Request canceled’, thrown.message);<br>    } else {<br>      // 处理错误<br>    }<br>  });</p><p>  // 取消请求（message 参数是可选的）<br>  source.cancel(‘Operation canceled by the user.’);<br>  还可以通过传递一个 executor 函数到 CancelToken 的构造函数来创建 cancel token：</p><p>  var CancelToken = axios.CancelToken;<br>  var cancel;</p><p>  axios.get(‘/user/12345’, {<br>    cancelToken: new CancelToken(function executor(c) {<br>      // executor 函数接收一个 cancel 函数作为参数<br>      cancel = c;<br>    })<br>  });</p><p>  // 取消请求<br>  cancel();<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">tip : 可以使用同一个 cancel token 取消多个请求</span><br><span class="line"></span><br><span class="line">## Promises</span><br><span class="line">axios 依赖原生的 ES6 Promise 实现而被支持.</span><br><span class="line">如果你的环境不支持 ES6 Promise，你可以使用 polyfill.</span><br><span class="line"></span><br><span class="line">## TypeScript</span><br><span class="line"> *axios includes TypeScript definitions*</span><br></pre></td></tr></table></figure></p><pre><code>import axios from &apos;axios&apos;;axios.get(&apos;/user?ID=12345&apos;);```    </code></pre><p>   <em>文章引用链接</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;##认识Axios&lt;br&gt;  Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。&lt;/p&gt;
&lt;h2 id=&quot;Features&quot;&gt;&lt;a href=&quot;#Features&quot; class=&quot;headerlink&quot; title=&quot;Featu
      
    
    </summary>
    
      <category term="技术" scheme="http://binzhizhu.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="axios" scheme="http://binzhizhu.github.io/tags/axios/"/>
    
  </entry>
  
  <entry>
    <title>Nginx 配置访问Access Denied</title>
    <link href="http://binzhizhu.github.io/2018/11/21/Nginx-%E9%85%8D%E7%BD%AE%E8%AE%BF%E9%97%AEAccess-Denied/"/>
    <id>http://binzhizhu.github.io/2018/11/21/Nginx-配置访问Access-Denied/</id>
    <published>2018-11-21T15:36:27.000Z</published>
    <updated>2018-11-21T15:36:58.816Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>  前段时间双11阿里云搞活动，于是便忍痛（花呗）入手了一台1核2G、40G系统盘、1M带宽的云服务ECS服务器。想着自己平时开发玩玩以及搭建自己的博客，所以就很爽快的买了，还顺便在阿里云买了一个.top的域名。<br>也就是博客现在的这个域名，域名申请备案后，大概半个月左右收到备案通过的通知，于是我就开始解析域名到服务器，同时也把自己的项目在服务器搭建好。<br>我是直接搭wget一键安装LNMP环境的，github clone下来，这个时候心想着配置一下虚拟域名应该就美滋滋了。</p><h3 id="搭建过程的遇到的问题"><a href="#搭建过程的遇到的问题" class="headerlink" title="搭建过程的遇到的问题"></a>搭建过程的遇到的问题</h3><h4 id="访问解析的域名连接重置"><a href="#访问解析的域名连接重置" class="headerlink" title="访问解析的域名连接重置"></a>访问解析的域名连接重置</h4><p>  我刚开始以为是域名解析的问题，因为访问域名是一直显示正在连接，最后显示连接重置，也就是说无法连接到服务器，于是我问了一下其他朋友，在阿里云服务器添加了安全组，默认开启所有连接。<br>其实开启http 80、https就可以了，其他看自己的需求，添加之后就不会显示连接重置了。</p><h4 id="访问提示Access-Denied"><a href="#访问提示Access-Denied" class="headerlink" title="访问提示Access Denied"></a>访问提示Access Denied</h4>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">access denied</span><br></pre></td></tr></table></figure><p>  mlgj… 难受，解决了一个问题又出现了另外一个问题，访问项目提示access denied。我前前后后检查过Nginx的配置，真的觉得没有问题…。Nginx 提示successful，重启也正常。<br>最让我觉得奇怪的是，访问域名提示access denied 的同时，可以看到网页的logo 已经访问到我项目的logo了，但是就完全没有任何反应，我自己去看Nginx日志也没相应的报错信息，我真的不知道该如何排查。</p><h4 id="重新clone项目部署"><a href="#重新clone项目部署" class="headerlink" title="重新clone项目部署"></a>重新clone项目部署</h4><p>  我只好重新clone项目 重新认真部署一次 看看效果如何 未完待续。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;  前段时间双11阿里云搞活动，于是便忍痛（花呗）入手了一台1核2G、40G系统盘、1M带宽的云服务ECS服务器。想着自己平时开发玩玩以及搭
      
    
    </summary>
    
      <category term="Nginx" scheme="http://binzhizhu.github.io/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="http://binzhizhu.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Vue.js结合ElementUI的（分页）进行前端分页</title>
    <link href="http://binzhizhu.github.io/2018/11/17/Vue-js%E7%BB%93%E5%90%88ElementUI%E7%9A%84%EF%BC%88%E5%88%86%E9%A1%B5%EF%BC%89%E8%BF%9B%E8%A1%8C%E5%89%8D%E7%AB%AF%E5%88%86%E9%A1%B5/"/>
    <id>http://binzhizhu.github.io/2018/11/17/Vue-js结合ElementUI的（分页）进行前端分页/</id>
    <published>2018-11-16T16:19:31.000Z</published>
    <updated>2018-11-17T06:30:58.908Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>  我们在开发的过程中总会遇到某些项目需要根据后台接口返回的数据进行前端分页显示，举个例子：电商项目中的订单列表页面。<br>后台点击订单列表页的时候会去请求后端接口，前端根据后端返回的订单数据进行分页显示。虽然自己是一个后端人员，但今天处理一个后台改版的任务的时候，<br>订单列表页用Vue写的，在对接写好的接口的时候，就遇到了这个分页的问题。那我们就一起来看下这个问题一般要如何解决吧。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>  大致的想法是：后台返回所有订单数据，然后前端拿到返回的数据进行全部分页，这里注意的是：例如有100条记录，每页显示10条，这个时候实际分页效果是10页对吧，也就是说我们是<br>后端一次性返回所有的订单数据，然后交给前端提前进行分页，每一页的数据我们在拿到后台返回的数据的时候前端就已经分好页了。</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol><li>分页切换的效果用户体验会更加顺畅；</li><li>当删除一条数据的时候过滤器会重新计算当前页面的显示数据</li></ol><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol><li>当页面数据量大的时候会浪费很多流量，因为有点类似于预加载的效果，一次把所有数据返回，数据多的时候RT时间会比较长</li></ol><h2 id="代码片段"><a href="#代码片段" class="headerlink" title="代码片段"></a>代码片段</h2><h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><p>  我们应该先创建一个过滤器来过滤列表数据，这里有三个参数tabledata（列表数据），pageNum（当前第几页），pagesize（每页条数）<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">filters:&#123;</span><br><span class="line">      pagination(tabledata,pageNum,pagesize)&#123;</span><br><span class="line">        let offset = (pageNum - 1) * pagesize;//当前页第一条的索引</span><br><span class="line">        let data=(offset + pagesize &gt;= tabledata.length) ? array.slice(offset, tabledata.length) : array.slice(offset, offset + pagesize);</span><br><span class="line">        return data</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;el-table :data=&quot;tableData | pagination(pageNum,pagesize)&quot;&gt;</span><br><span class="line">      &lt;el-table-column label=&quot;&quot;&gt;</span><br><span class="line">          &lt;template slot-scope=&quot;scope&quot;&gt;</span><br><span class="line">              </span><br><span class="line">          &lt;/template&gt;</span><br><span class="line">      &lt;/el-table-column&gt;</span><br><span class="line">    &lt;/el-table&gt;</span><br><span class="line">    &lt;el-pagination</span><br><span class="line">     @size-change=&quot;handleSizeChange&quot;</span><br><span class="line">      @current-change=&quot;handleCurrentChange&quot; </span><br><span class="line">      :current-page=&quot;pageNo&quot; </span><br><span class="line">      :page-size=&quot;pageSize&quot; </span><br><span class="line">      layout=&quot; prev, pager, next, sizes, jumper&quot; </span><br><span class="line">      :total=&quot;tableData.length&quot;&gt;</span><br><span class="line">      &lt;/el-pagination&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>  <a id="more"></a><p>  上面是elementui 的pagination 分页组件代码片段，不理解的直接去看文档即可 </p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  export default&#123;</span><br><span class="line">    data()&#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        tableData: [&#123;</span><br><span class="line">             id:&apos;&apos;,</span><br><span class="line">             name:&apos;&apos;,</span><br><span class="line">        &#125;],</span><br><span class="line">        pagenum: 1,</span><br><span class="line">        pagesize:10</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">      handleSizeChange(val) &#123;</span><br><span class="line">       console.log(`每页 $&#123;val&#125; 条`); </span><br><span class="line">        this.pagesize=val;</span><br><span class="line">      &#125;,</span><br><span class="line">      handleCurrentChange(val) &#123;</span><br><span class="line">      console.log(`当前页: $&#123;val&#125;`);</span><br><span class="line">        this.pageNum = val;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  filters:&#123;</span><br><span class="line">        pagination(tabledata,pageNum,pagesize)&#123;</span><br><span class="line">          let offset = (pageNum - 1) * pagesize;//当前页第一条的索引</span><br><span class="line">          let data=(offset + pagesize &gt;= tabledata.length) ? array.slice(offset, tabledata.length) : array.slice(offset, offset + pagesize);</span><br><span class="line">          return data</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>  总结：这种做法就比较舒服，用户体验也很好，切换分页的时候会很流畅。但还有另外的做法就是通过单页数据返回，每一次切换分页的时候去请求当前这个页面的数据，<br>但是这种做法需要自己写上一页、下一页的方法，用户点击的时候去请求当前页面的数据去渲染，并不是一次性返回所有数据，这也是这种方法的优势，总的来说还得看具体的业务场景。</p><h2 id="最后当然要贴一波效果图啊"><a href="#最后当然要贴一波效果图啊" class="headerlink" title="最后当然要贴一波效果图啊"></a>最后当然要贴一波效果图啊</h2><p><img src="/blogimages/11-17.png" alt="分页效果"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;  我们在开发的过程中总会遇到某些项目需要根据后台接口返回的数据进行前端分页显示，举个例子：电商项目中的订单列表页面。&lt;br&gt;后台点击订单列表页的时候会去请求后端接口，前端根据后端返回的订单数据进行分页显示。虽然自己是一个后端人员，但今天处理一个后台改版的任务的时候，&lt;br&gt;订单列表页用Vue写的，在对接写好的接口的时候，就遇到了这个分页的问题。那我们就一起来看下这个问题一般要如何解决吧。&lt;/p&gt;
&lt;h2 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h2&gt;&lt;p&gt;  大致的想法是：后台返回所有订单数据，然后前端拿到返回的数据进行全部分页，这里注意的是：例如有100条记录，每页显示10条，这个时候实际分页效果是10页对吧，也就是说我们是&lt;br&gt;后端一次性返回所有的订单数据，然后交给前端提前进行分页，每一页的数据我们在拿到后台返回的数据的时候前端就已经分好页了。&lt;/p&gt;
&lt;h2 id=&quot;优点&quot;&gt;&lt;a href=&quot;#优点&quot; class=&quot;headerlink&quot; title=&quot;优点&quot;&gt;&lt;/a&gt;优点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;分页切换的效果用户体验会更加顺畅；&lt;/li&gt;
&lt;li&gt;当删除一条数据的时候过滤器会重新计算当前页面的显示数据&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;缺点&quot;&gt;&lt;a href=&quot;#缺点&quot; class=&quot;headerlink&quot; title=&quot;缺点&quot;&gt;&lt;/a&gt;缺点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;当页面数据量大的时候会浪费很多流量，因为有点类似于预加载的效果，一次把所有数据返回，数据多的时候RT时间会比较长&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;代码片段&quot;&gt;&lt;a href=&quot;#代码片段&quot; class=&quot;headerlink&quot; title=&quot;代码片段&quot;&gt;&lt;/a&gt;代码片段&lt;/h2&gt;&lt;h3 id=&quot;过滤器&quot;&gt;&lt;a href=&quot;#过滤器&quot; class=&quot;headerlink&quot; title=&quot;过滤器&quot;&gt;&lt;/a&gt;过滤器&lt;/h3&gt;&lt;p&gt;  我们应该先创建一个过滤器来过滤列表数据，这里有三个参数tabledata（列表数据），pageNum（当前第几页），pagesize（每页条数）&lt;br&gt;  &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;filters:&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      pagination(tabledata,pageNum,pagesize)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        let offset = (pageNum - 1) * pagesize;//当前页第一条的索引&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        let data=(offset + pagesize &amp;gt;= tabledata.length) ? array.slice(offset, tabledata.length) : array.slice(offset, offset + pagesize);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return data&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;完整代码&quot;&gt;&lt;a href=&quot;#完整代码&quot; class=&quot;headerlink&quot; title=&quot;完整代码&quot;&gt;&lt;/a&gt;完整代码&lt;/h3&gt;  &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;template&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;el-table :data=&amp;quot;tableData | pagination(pageNum,pagesize)&amp;quot;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;lt;el-table-column label=&amp;quot;&amp;quot;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &amp;lt;template slot-scope=&amp;quot;scope&amp;quot;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &amp;lt;/template&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;lt;/el-table-column&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;/el-table&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;el-pagination&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     @size-change=&amp;quot;handleSizeChange&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      @current-change=&amp;quot;handleCurrentChange&amp;quot; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      :current-page=&amp;quot;pageNo&amp;quot; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      :page-size=&amp;quot;pageSize&amp;quot; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      layout=&amp;quot; prev, pager, next, sizes, jumper&amp;quot; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      :total=&amp;quot;tableData.length&amp;quot;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;lt;/el-pagination&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;/template&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="前端" scheme="http://binzhizhu.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Vue" scheme="http://binzhizhu.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>解决Hexo首页阅读次数样式诡异的问题</title>
    <link href="http://binzhizhu.github.io/2018/11/16/%E8%A7%A3%E5%86%B3Hexo%E9%A6%96%E9%A1%B5%E9%98%85%E8%AF%BB%E6%AC%A1%E6%95%B0%E6%A0%B7%E5%BC%8F%E8%AF%A1%E5%BC%82%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://binzhizhu.github.io/2018/11/16/解决Hexo首页阅读次数样式诡异的问题/</id>
    <published>2018-11-16T02:19:43.000Z</published>
    <updated>2018-11-17T04:44:53.145Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>  今晚在完善阅读统计的功能是时候发现一个很诡异的问题，我们一起来探讨一下。上一篇文章大概有阐述阅读统计功能的搭建，所有这里我就不多说了。<br>  利用leancloud接完统计功能后，当前这个hexo版本我会发现首页的阅读数量的样式有点诡异，大致如下：<br>  两种情况： 1：<em>阅读次数::9:9</em>   :2：<em>阅读次数::99</em><br>  实际上这个时候我们的阅读量只有9而已，正常来说应该这样显示：  <em>阅读次数：9</em><br>  于是我忍不住摁住F12一探究竟,大致可以知道阅读次数那一块的元素是js直接赋值的，所以我就去找了一下阅读统计的部分的相关js，我比较粗暴，直接定位全局搜索一波 <em>leancloud_visitors</em>  相关的文件<br>  这是我们可以找到一个路径为 <em>themes\next\layout_third-party\analytics\lean-analytics.swig</em> 的文件，打开发现就是这部分js处理leancloud的阅读数量统计。 </p><p> <img src="/blogimages/11-16.png" alt="今天的我"></p> <a id="more"></a><h3 id="贴一波阅读次数统计的代码-LeanCloud提供支持"><a href="#贴一波阅读次数统计的代码-LeanCloud提供支持" class="headerlink" title="贴一波阅读次数统计的代码(LeanCloud提供支持)"></a>贴一波阅读次数统计的代码(LeanCloud提供支持)</h3>  <figure class="highlight javascript"><figcaption><span>看到function showTime 我相信你已经很明白了</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#123;% <span class="keyword">if</span> theme.leancloud_visitors.enable %&#125;</span><br><span class="line"></span><br><span class="line">  &#123;# custom analytics part create by xiamo #&#125;</span><br><span class="line"> &lt;script src=<span class="string">"https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"</span>&gt;&lt;/script&gt;</span><br><span class="line"> &lt;script&gt;AV.initialize(<span class="string">"&#123;&#123;theme.leancloud_visitors.app_id&#125;&#125;"</span>, <span class="string">"&#123;&#123;theme.leancloud_visitors.app_key&#125;&#125;"</span>);&lt;/script&gt;</span><br><span class="line"> &lt;script&gt;</span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">showTime</span>(<span class="params">Counter</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.warn(<span class="string">'~欢迎光临我的博客 Email:binzhizhu@gmail.com '</span>)</span><br><span class="line"> <span class="keyword">var</span> query = <span class="keyword">new</span> AV.Query(Counter);</span><br><span class="line"> $(<span class="string">".leancloud_visitors"</span>).each(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">var</span> url = $(<span class="keyword">this</span>).attr(<span class="string">"id"</span>).trim();</span><br><span class="line"> query.equalTo(<span class="string">"url"</span>, url);</span><br><span class="line"> query.find(&#123;</span><br><span class="line"> success: <span class="function"><span class="keyword">function</span>(<span class="params">results</span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.warn(<span class="string">'--这里是阅读统计代码-- by --leancloud--'</span>)</span><br><span class="line"> <span class="keyword">if</span> (results.length == <span class="number">0</span>) &#123;</span><br><span class="line"> <span class="keyword">var</span> content = $(<span class="built_in">document</span>.getElementById(url)).text() + <span class="string">': 0'</span>;</span><br><span class="line"> $(<span class="built_in">document</span>.getElementById(url)).text(content);</span><br><span class="line"> <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; results.length; i++) &#123;</span><br><span class="line"> <span class="keyword">var</span> object = results[i];</span><br><span class="line"> <span class="keyword">var</span> content = $(<span class="built_in">document</span>.getElementById(url)).text() + object.attributes.time;</span><br><span class="line"> $(<span class="built_in">document</span>.getElementById(url)).text(content);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;,</span><br><span class="line"> error: <span class="function"><span class="keyword">function</span>(<span class="params">object, error</span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">"Error: "</span> + error.code + <span class="string">" "</span> + error.message);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;);</span><br><span class="line"></span><br><span class="line"> &#125;);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>  上述代码中的 for循环，看起来是没任何问题。但我hexo g -d 到GitHubPage 的时候，我再for循环里面console.log(‘obj’,object),打印了一下当前文章的所有属性，发现同一篇文章会打印两次，所有才会出现上面所说的 <em>阅读次数::99</em>的情况。相当于第一次循环time是9，循环了两次拼接了起来于是变成<em>阅读次数::99</em><br>  所有我 直接在for循环的最后加了一句  </p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return;</span><br></pre></td></tr></table></figure><h3 id="真-阅读统计代码段"><a href="#真-阅读统计代码段" class="headerlink" title="真.阅读统计代码段"></a>真.阅读统计代码段</h3><p>  这么做实际上很简单，类似于做一层兼容了，确保不会重复循环，修复了之后发现真的没有问题了，阅读次数显示正常了，美滋滋，这也是一种收获。顺便也贴一下其他阅读统计事件的代码片段吧：<br>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"> function addCount(Counter) &#123;</span><br><span class="line"> var Counter = AV.Object.extend(&quot;Counter&quot;);</span><br><span class="line"> url = $(&quot;.leancloud_visitors&quot;).attr(&apos;id&apos;).trim();</span><br><span class="line"> title = $(&quot;.leancloud_visitors&quot;).attr(&apos;data-flag-title&apos;).trim();</span><br><span class="line"> var query = new AV.Query(Counter);</span><br><span class="line"> query.equalTo(&quot;url&quot;, url);</span><br><span class="line"> query.find(&#123;</span><br><span class="line"> success: function(results) &#123;</span><br><span class="line"> if (results.length &gt; 0) &#123;</span><br><span class="line"> var counter = results[0];</span><br><span class="line"> counter.fetchWhenSave(true);</span><br><span class="line"> counter.increment(&quot;time&quot;);</span><br><span class="line"> counter.save(null, &#123;</span><br><span class="line"> success: function(counter) &#123;</span><br><span class="line"> var content = $(document.getElementById(url)).text() + &apos;: &apos; + counter.get(&apos;time&apos;);</span><br><span class="line"> $(document.getElementById(url)).text(content);</span><br><span class="line"> &#125;,</span><br><span class="line"> error: function(counter, error) &#123;</span><br><span class="line"> console.log(&apos;Failed to save Visitor num, with error message: &apos; + error.message);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;);</span><br><span class="line"> &#125; else &#123;</span><br><span class="line"> var newcounter = new Counter();</span><br><span class="line"> newcounter.set(&quot;title&quot;, title);</span><br><span class="line"> newcounter.set(&quot;url&quot;, url);</span><br><span class="line"> newcounter.set(&quot;time&quot;, 1);</span><br><span class="line"> newcounter.save(null, &#123;</span><br><span class="line"> success: function(newcounter) &#123;</span><br><span class="line">     console.log(&quot;newcounter.get(&apos;time&apos;)=&quot;+newcounter.get(&apos;time&apos;));</span><br><span class="line"> var content = $(document.getElementById(url)).text() + &apos;: &apos; + newcounter.get(&apos;time&apos;);</span><br><span class="line"> $(document.getElementById(url)).text(content);</span><br><span class="line"> &#125;,</span><br><span class="line"> error: function(newcounter, error) &#123;</span><br><span class="line"> console.log(&apos;Failed to create&apos;);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;,</span><br><span class="line"> error: function(error) &#123;</span><br><span class="line"> console.log(&apos;Error:&apos; + error.code + &quot; &quot; + error.message);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;);</span><br><span class="line"> &#125;</span><br><span class="line"> $(function() &#123;</span><br><span class="line"> var Counter = AV.Object.extend(&quot;Counter&quot;);</span><br><span class="line"> if ($(&apos;.leancloud_visitors&apos;).length == 1) &#123;</span><br><span class="line"> addCount(Counter);</span><br><span class="line"> &#125; else if ($(&apos;.post-title-link&apos;).length &gt; 1) &#123;</span><br><span class="line"> showTime(Counter);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;);</span><br><span class="line"> &lt;/script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure></p><p> 这篇博客写得我有点疲惫了，已经深夜十分了，准备入睡啦，明天还要起来搬砖呢，晚安各位，希望能够帮助到大家吧，我也是刚学习Hexo自己搭建博客。<br> 但有趣的一点是我们可以在这些开源的框架或者资源里面肆意的玩弄代码，hexo其实就是提供给大家开源开发的，看着文档接服务就好了，一大推的第三方服务已经Api。<br> 最后发一个今天的自拍吧 哈哈哈！！！</p><p> <img src="/blogimages/11-16.png" alt="今天的我"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;  今晚在完善阅读统计的功能是时候发现一个很诡异的问题，我们一起来探讨一下。上一篇文章大概有阐述阅读统计功能的搭建，所有这里我就不多说了。&lt;br&gt;  利用leancloud接完统计功能后，当前这个hexo版本我会发现首页的阅读数量的样式有点诡异，大致如下：&lt;br&gt;  两种情况： 1：&lt;em&gt;阅读次数::9:9&lt;/em&gt;   :2：&lt;em&gt;阅读次数::99&lt;/em&gt;&lt;br&gt;  实际上这个时候我们的阅读量只有9而已，正常来说应该这样显示：  &lt;em&gt;阅读次数：9&lt;/em&gt;&lt;br&gt;  于是我忍不住摁住F12一探究竟,大致可以知道阅读次数那一块的元素是js直接赋值的，所以我就去找了一下阅读统计的部分的相关js，我比较粗暴，直接定位全局搜索一波 &lt;em&gt;leancloud_visitors&lt;/em&gt;  相关的文件&lt;br&gt;  这是我们可以找到一个路径为 &lt;em&gt;themes\next\layout_third-party\analytics\lean-analytics.swig&lt;/em&gt; 的文件，打开发现就是这部分js处理leancloud的阅读数量统计。 &lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;/blogimages/11-16.png&quot; alt=&quot;今天的我&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Hexo" scheme="http://binzhizhu.github.io/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="http://binzhizhu.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>为NexT主题添加文章阅读量统计功能</title>
    <link href="http://binzhizhu.github.io/2018/11/15/%E4%B8%BANexT%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E9%87%8F%E7%BB%9F%E8%AE%A1%E5%8A%9F%E8%83%BD/"/>
    <id>http://binzhizhu.github.io/2018/11/15/为NexT主题添加文章阅读量统计功能/</id>
    <published>2018-11-14T16:05:57.000Z</published>
    <updated>2018-11-14T16:13:37.801Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近刚入门Hexo+GithubPage搭建个人博客，基础的搭建完毕之后，总觉得缺少些技术性（代表）的功能，于是想到要不要在自己的博客搭建阅读统计的功能？但这个时候不太明白如何去实现，网上看了其他博主的一些建议之后，也打算使用learncloud这家服务商的资源解决我们的问题，所以我们得先去learncloud官网注册账号。<br><a id="more"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近刚入门Hexo+GithubPage搭建个人博客，基础的搭建完毕之后，总觉得缺少些技术性（代表）的功能，于是想到要不要在自己的博客搭建阅读统计的功能？但这个时候不太明白如何去实现，网上看了其他博主的一些建议之后，也打算使用learncloud这家服务商的资源解决我们的问题，所以我们得先去learncloud官网注册账号。&lt;br&gt;
    
    </summary>
    
      <category term="Hexo" scheme="http://binzhizhu.github.io/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="http://binzhizhu.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>尝试使用Hexo+Github搭建个人博客</title>
    <link href="http://binzhizhu.github.io/2018/11/14/%E5%B0%9D%E8%AF%95%E4%BD%BF%E7%94%A8Hexo-Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>http://binzhizhu.github.io/2018/11/14/尝试使用Hexo-Github搭建个人博客/</id>
    <published>2018-11-13T16:14:26.000Z</published>
    <updated>2018-11-14T16:07:30.534Z</updated>
    
    <content type="html"><![CDATA[<p>##初探Hexo</p><p>Hexo是一款基于Node.js的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在GitHub和Heroku上，是搭建博客的首选框架。这里我们选用的是GitHub，你没看错，全球最大的同性恋交友网站（逃……）。<br>Hexo同时也是GitHub上的开源项目，参见：hexojs/hexo 如果想要更加全面的了解Hexo，可以到其官网 Hexo 了解更多的细节，因为Hexo的创建者是台湾人，对中文的支持很友好，可以选择中文进行查看。这里，默认各位猿/媛儿都知道GitHub就不再赘述。<br><a id="more"></a></p><p>##搭建步骤</p><p>1.获得个人网站域名<br>2.GitHub创建个人仓库<br>3.安装Git<br>4.安装Node.js<br>5.安装Hexo<br>6.推送网站<br>7.绑定域名<br>8.更换主题<br>9.初识MarkDown语法<br>10.发布文章<br>11.寻找图床<br>12.个性化设置</p><p>##关于博主</p><p>本人博客地址：<a href="https://binzhizhu.github.io">https://binzhizhu.github.io</a><br>交流：<a href="mailto:binzhizhu@gmail.com" target="_blank" rel="noopener">binzhizhu@gmail.com</a><br>网站：<a href="http://www.binzhizhu.top" target="_blank" rel="noopener">www.binzhizhu.top</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;##初探Hexo&lt;/p&gt;
&lt;p&gt;Hexo是一款基于Node.js的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在GitHub和Heroku上，是搭建博客的首选框架。这里我们选用的是GitHub，你没看错，全球最大的同性恋交友网站（逃……）。&lt;br&gt;Hexo同时也是GitHub上的开源项目，参见：hexojs/hexo 如果想要更加全面的了解Hexo，可以到其官网 Hexo 了解更多的细节，因为Hexo的创建者是台湾人，对中文的支持很友好，可以选择中文进行查看。这里，默认各位猿/媛儿都知道GitHub就不再赘述。&lt;br&gt;
    
    </summary>
    
      <category term="Hexo" scheme="http://binzhizhu.github.io/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="http://binzhizhu.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>北岛-《回答》</title>
    <link href="http://binzhizhu.github.io/2018/11/14/%E5%8C%97%E5%B2%9B-%E3%80%8A%E5%9B%9E%E7%AD%94%E3%80%8B/"/>
    <id>http://binzhizhu.github.io/2018/11/14/北岛-《回答》/</id>
    <published>2018-11-13T16:05:05.000Z</published>
    <updated>2018-11-16T02:13:51.880Z</updated>
    
    <content type="html"><![CDATA[<p>卑鄙是卑鄙者的通行证，<br>高尚是高尚者的墓志铭，<br>看吧，在那镀金的天空中，<br>飘满了死者弯曲的倒影。</p><p>冰川纪过去了，<br>为什么到处都是冰凌？<br>好望角发现了，<br>为什么死海里千帆相竞？</p><a id="more"></a><p>我来到这个世界上，<br>只带着纸、绳索和身影，<br>为了在审判之前，<br>宣读那些被判决的声音。</p><p>告诉你吧，世界<br>我–不–相–信！<br>纵使你脚下有一千名挑战者，<br>那就把我算作第一千零一名。</p><p>我不相信天是蓝的，<br>我不相信雷的回声，<br>我不相信梦是假的，<br>我不相信死无报应。</p><p>如果海洋注定要决堤，<br>就让所有的苦水都注入我心中，<br>如果陆地注定要上升，<br>就让人类重新选择生存的峰顶。</p><p>新的转机和闪闪星斗，<br>正在缀满没有遮拦的天空。<br>那是五千年的象形文字，<br>那是未来人们凝视的眼睛。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;卑鄙是卑鄙者的通行证，&lt;br&gt;高尚是高尚者的墓志铭，&lt;br&gt;看吧，在那镀金的天空中，&lt;br&gt;飘满了死者弯曲的倒影。&lt;/p&gt;
&lt;p&gt;冰川纪过去了，&lt;br&gt;为什么到处都是冰凌？&lt;br&gt;好望角发现了，&lt;br&gt;为什么死海里千帆相竞？&lt;/p&gt;
    
    </summary>
    
      <category term="诗" scheme="http://binzhizhu.github.io/categories/%E8%AF%97/"/>
    
    
      <category term="现代诗" scheme="http://binzhizhu.github.io/tags/%E7%8E%B0%E4%BB%A3%E8%AF%97/"/>
    
      <category term="朦胧诗" scheme="http://binzhizhu.github.io/tags/%E6%9C%A6%E8%83%A7%E8%AF%97/"/>
    
      <category term="感悟" scheme="http://binzhizhu.github.io/tags/%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
</feed>
